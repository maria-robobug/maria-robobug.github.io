<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Distributed Transactions from the .NET SDK | Couchbase Docs (Local)</title>
<link rel="canonical" href="https://maria-robobug.github.io/dotnet-sdk/3.3/howtos/distributed-acid-transactions-from-the-sdk.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="A practical guide to using Couchbase&#x27;s distributed ACID transactions, via the .NET API.">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="dotnet-sdk">
<meta name="dcterms.identifier" content="3.3">
<meta name="page-url" content="/dotnet-sdk/3.3/howtos/distributed-acid-transactions-from-the-sdk.html">
<meta name="generator" content="Antora 3.0.1">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://maria-robobug.github.io/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="https://maria-robobug.github.io/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../cloud/index.html">
                      Capella
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../cloud-native-database/index.html">
                      Cloud-Native
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="2">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/pages/distributed-acid-transactions-from-the-sdk.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../hello-world/overview.html">.NET SDK</a></li>
<li class="crumb">Advanced Data Operations</li>
<li class="crumb"><a href="distributed-acid-transactions-from-the-sdk.html">Distributed ACID Transactions</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Distributed Transactions from the .NET SDK</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
A practical guide to using Couchbase&#8217;s distributed ACID transactions, via the .NET API.
</blockquote>
</div>
<div class="paragraph">
<p>Couchbase Distributed <a href="../../../server/7.1/learn/data/transactions.html#overview" class="xref page">ACID (atomic, consistent, isolated, and durable)</a> Transactions allow applications to perform a series of database operations as a single unit&#8201;&#8212;&#8201;meaning operations are either committed together or all undone.
Transactions are distributed and work across multiple documents, buckets, scopes, and collections, which can reside on multiple nodes.</p>
</div>
<div class="paragraph">
<p>Below we show you how to create Transactions, step-by-step.
You may also want to start with our <a href="https://github.com/couchbaselabs/couchbase-transactions-dotnet-examples">transactions examples repository</a>,
which features useful downloadable examples of using Distributed Transactions.</p>
</div>
<div class="paragraph">
<p>API Docs are available <a href="https://docs.couchbase.com/sdk-api/couchbase-transactions-dotnet/">online</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="requirements"><a class="anchor" href="#requirements"></a>Requirements</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Couchbase Server 6.6.2 or above.</p>
</li>
<li>
<p>Couchbase .NET client 3.2.3 or above.
It is recommended you use the package on NuGet.
.Single Node Cluster</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>When using a single node cluster (for example, during development), the default number of replicas for a newly created bucket is <strong>1</strong>.
If left at this default, all key-value writes performed with durability will fail with a <code>DurabilityImpossibleException</code>.
In turn, this will cause all transactions (which perform all key-value writes durably) to fail.
This setting can be changed via:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../../../cloud/clusters/data-service/manage-buckets.html#add-bucket" class="xref page">Capella UI</a></p>
</li>
<li>
<p><a href="../../../server/7.1/manage/manage-buckets/create-bucket.html#couchbase-bucket-settings" class="xref page">Couchbase Server UI</a></p>
</li>
<li>
<p><a href="../../../server/7.1/cli/cbcli/couchbase-cli-bucket-create.html#options" class="xref page">Command Line</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the bucket already exists, then the server needs to be rebalanced for the setting to take affect.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase transactions require no additional components or services to be configured.
Simply add the transactions library into your project.
Version 1.1.0 was release October 29th, 2021.
See the <a href="../project-docs/distributed-transactions-dotnet-release-notes.html" class="xref page">Release Notes</a> for the latest version.</p>
</div>
<div class="paragraph">
<p>With NuGut this can be accomplished by using the NuGet Package Manager in your IDE:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">PM &gt; Install-Package Couchbase.Transactions -Version 1.1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or via the CLI</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">dotnet add package Couchbase.Transactions --version 1.1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or by using PackageReference in your .csproj file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">&lt;PackageReference Include="Couchbase.Transactions" Version="1.1.0" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A complete simple NuGet example is available on our <a href="https://github.com/couchbaselabs/couchbase-transactions-dotnet-examples">transactions examples repository</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initializing-transactions"><a class="anchor" href="#initializing-transactions"></a>Initializing Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here are all imports used by the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L2-L11">using System;
using System.Linq;
using System.Threading.Tasks;
using Couchbase.KeyValue;
using Couchbase.Query;
using Couchbase.Transactions.Config;
using Couchbase.Transactions.Error;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json.Linq;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The starting point is the <code>Transactions</code> object.
It is very important that the application ensures that only one of these is created per cluster, as it performs automated background clean-up processes that should not be duplicated.
In dependency injection context, this instance should be injected as a singleton.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L35-L42">// Initialize the Couchbase cluster
var options = new ClusterOptions().WithCredentials("Administrator", "password");
var cluster = await Cluster.ConnectAsync("couchbase://localhost", options).ConfigureAwait(false);
var bucket = await cluster.BucketAsync("default").ConfigureAwait(false);
var collection = bucket.DefaultCollection();

// Create the single Transactions object
var transactions = Transactions.Create(cluster, TransactionConfigBuilder.Create());</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="multiple-transactions-objects"><a class="anchor" href="#multiple-transactions-objects"></a>Multiple Transactions Objects</h3>
<div class="paragraph">
<p>Generally an application will need just one <code>Transactions</code> object, and in fact the library will usually warn if more are created.
Each <code>Transactions</code> object uses some resources, including a thread-pool.</p>
</div>
<div class="paragraph">
<p>There is one rare exception where an application may need to create multiple <code>Transactions</code> objects, which is covered in <a href="#Custom Metadata Collections">[Custom Metadata Collections]</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transactions can optionally be configured at the point of creating the <code>Transactions</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L54-L57">var transactions = Transactions.Create(_cluster,
    TransactionConfigBuilder.Create()
        .DurabilityLevel(DurabilityLevel.PersistToMajority)
        .Build());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration will perform all writes with the durability setting <code>Majority</code>, ensuring that each write is available in-memory on the majority of replicas before the transaction continues.
There are two higher durability settings available that will additionally wait for all mutations to be written to physical storage on either the active or the majority of replicas, before continuing.
This further increases safety, at a cost of additional latency.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
A level of <code>None</code> is present but its use is discouraged and unsupported.
If durability is set to <code>None</code>, then ACID semantics are not guaranteed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To create a transaction, an application must supply its logic inside a <code>{lambda}</code>, including any conditional logic required.
Once the {lambda} has successfully run to conclusion, the transaction will be automatically committed.
If at any point an error occurs, the transaction will rollback and the {lambda} may run again.</p>
</div>
<div class="paragraph">
<p>As with the Couchbase .NET Client, you should use the library asynchronusly using the async/await keywords (the exceptions will be explained later in <a href="#Error Handling">[Error Handling]</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L84-L110">try
{
    await _transactions.RunAsync(async (ctx)=&gt;
    {
        // 'ctx' is an AttemptContext, which permits getting, inserting,
        // removing and replacing documents, along with committing and
        // rolling back the transaction.

        // ... Your transaction logic here ...

        // This call is optional - if you leave it off, the transaction
        // will be committed anyway.
        await ctx.CommitAsync().ConfigureAwait(false);
    }).ConfigureAwait(false);
}
catch (TransactionCommitAmbiguousException e)
{
    // The application will of course want to use its own logging rather
    // than Console.WriteLine
    Console.Error.WriteLine("Transaction possibly committed");
    Console.Error.WriteLine(e);
}
catch (TransactionFailedException e)
{
    Console.Error.WriteLine("Transaction did not reach commit point");
    Console.Error.WriteLine(e);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The asynchronous API allows you to use the thread pool, which can help you scale with excellent efficiency.
However, operations inside an individual transaction should be kept in-order and executed using <code>await</code> immediately.
Do not use fire-and-forget tasks under any circumstances.</p>
</div>
<div id="lambda-ops" class="paragraph">
<p>The transaction lambda gets passed an <code>AttemptContext</code> object&#8201;&#8212;&#8201;generally referred to as <code>ctx</code> in these examples.
Since the {lambda} could be rerun multiple times, it is important that it does not contain any side effects.
In particular, you should never perform regular operations on a <code>Collection</code>, such as <code>collection.InsertAsync()</code>, inside the lambda.
Such operations may be performed multiple times, and will not be performed transactionally.
Instead, you should perform these operations through the <code>ctx</code> object, e.g. <code>ctx.InsertAsync()</code>.</p>
</div>
<div class="paragraph">
<p>The result of a transaction is represented by a <code>TransactionResult</code> object, which can be used to expose debugging and logging information to help track what happened during a transaction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L117-L153">try
{
    var result = await _transactions.RunAsync(async (ctx) =&gt;
    {
        // Inserting a doc:
        var insertedDoc = await ctx.InsertAsync(_collection, "doc-a", new {}).ConfigureAwait(false);

        // Getting documents:
        // Use ctx.GetAsync if the document should exist, and the transaction
        // will fail if it does not
        var docA = await ctx.GetAsync(_collection, "doc-a").ConfigureAwait(false);

        // Replacing a doc:
        var docB = await ctx.GetAsync(_collection, "doc-b").ConfigureAwait(false);
        var content = docB.ContentAs&lt;dynamic&gt;();
        content.put("transactions", "are awesome");
        var replacedDoc = await ctx.ReplaceAsync(docB, content);

        // Removing a doc:
        var docC = await ctx.GetAsync(_collection, "doc-c").ConfigureAwait(false);
        await ctx.RemoveAsync(docC).ConfigureAwait(false);

        // This call is optional - if you leave it off, the transaction
        // will be committed anyway.
        await ctx.CommitAsync().ConfigureAwait(false);
    }).ConfigureAwait(false);
}
catch (TransactionCommitAmbiguousException e)
{
    Console.WriteLine("Transaction possibly committed");
    Console.WriteLine(e);
}
catch (TransactionFailedException e)
{
    Console.WriteLine("Transaction did not reach commit point");
    Console.WriteLine(e);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A core idea of Couchbase transactions is that an application supplies the logic for the transaction inside a <em>lambda</em>, including any conditional logic required, and the transaction is then automatically committed.
If a transient error occurs, such as a temporary conflict with another transaction, then the transaction will rollback what has been done so far and run the lambda again.
The application does not have to do these retries and error handling itself.</p>
</div>
<div class="paragraph">
<p>Each run of the lambda is called an <code>attempt</code>, inside an overall <code>transaction</code>.</p>
</div>
<div class="sect2">
<h3 id="active-transaction-record-entries"><a class="anchor" href="#active-transaction-record-entries"></a>Active Transaction Record Entries</h3>
<div class="paragraph">
<p>The first mechanic is that each of these attempts adds an entry to a metadata document in the Couchbase cluster.
These metadata documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Are named Active Transaction Records, or ATRs.</p>
</li>
<li>
<p>Are created and maintained automatically.</p>
</li>
<li>
<p>Begin with <code>_txn:atr-</code>.</p>
</li>
<li>
<p>Each contain entries for multiple attempts.</p>
</li>
<li>
<p>Are viewable, and <em>should not be modified externally</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each such ATR entry stores some metadata and, crucially, whether the attempt has committed or not.
In this way, the entry acts as the single point of truth for the transaction, which is essential for providing an 'atomic commit' during reads.</p>
</div>
</div>
<div class="sect2">
<h3 id="staged-mutations"><a class="anchor" href="#staged-mutations"></a>Staged Mutations</h3>
<div class="paragraph">
<p>The second mechanic is that mutating a document inside a transaction, does not directly change the body of the document.
Instead, the post-transaction version of the document is staged alongside the document (technically in its <a href="../concept-docs/xattr.html" class="xref page">extended attributes (XATTRs)</a>).
In this way, all changes are invisible to all parts of Couchbase until the commit point is reached.</p>
</div>
<div class="paragraph">
<p>These staged document changes effectively act as a lock against other transactions trying to modify the document, preventing write-write conflicts.</p>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>Cleanup</h3>
<div class="paragraph">
<p>There are safety mechanisms to ensure that leftover staged changes from a failed transaction cannot block live transactions indefinitely.
These include an asynchronous cleanup process that is started with the creation of the <code>Transactions</code> object, and scans for expired transactions created by any application, on all buckets.</p>
</div>
<div class="paragraph">
<p>The cleanup process is detailed in the <a href="#concept-docs:transactions-cleanup.adoc" class="xref unresolved">concept-docs:transactions-cleanup.adoc</a> page.</p>
</div>
</div>
<div class="sect2">
<h3 id="committing"><a class="anchor" href="#committing"></a>Committing</h3>
<div class="paragraph">
<p>Only once the lambda has successfully run to conclusion, will the attempt be committed.
This updates the ATR entry, which is used as a signal by transactional actors to use the post-transaction version of a document from its XATTRs.
Hence, updating the ATR entry is an 'atomic commit' switch for the transaction.</p>
</div>
<div class="paragraph">
<p>After this commit point is reached, the individual documents will be committed (or "unstaged").
This provides an eventually consistent commit for non-transactional actors.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="key-value-mutations"><a class="anchor" href="#key-value-mutations"></a>Key-Value Mutations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="replacing"><a class="anchor" href="#replacing"></a>Replacing</h3>
<div class="paragraph">
<p>Replacing a document requires awaiting a <code>TransactionGetResult</code> returned from <code>ctx.GetAsync()</code>, <code>ctx.InsertAsync()</code>, or another <code>ctx.ReplaceAsync()</code> call first.
This is necessary to ensure that the document is not involved in another transaction.
(If it is, then the transaction will handle this, generally by rolling back what has been done so far, and retrying the lambda.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L195-L201">await _transactions.RunAsync(async ctx =&gt;
{
    var anotherDoc = await ctx.GetAsync(_collection, "anotherDoc").ConfigureAwait(false);
    var content = anotherDoc.ContentAs&lt;dynamic&gt;();
    content.put("transactions", "are awesome");
    _ = await ctx.ReplaceAsync(anotherDoc, content);
}).ConfigureAwait(false);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="removing"><a class="anchor" href="#removing"></a>Removing</h3>
<div class="paragraph">
<p>As with replaces, removing a document requires awaiting a <code>TransactionGetResult</code> from a previous transaction operation first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L208-L212">await _transactions.RunAsync(async ctx =&gt;
{
    var anotherDoc = await ctx.GetAsync(_collection, "anotherDoc").ConfigureAwait(false);
    await ctx.RemoveAsync(anotherDoc).ConfigureAwait(false);
}).ConfigureAwait(false);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inserting"><a class="anchor" href="#inserting"></a>Inserting</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L160-L164">await _transactions.RunAsync(async ctx =&gt;
{
    var insertedDoc = await ctx.InsertAsync(_collection, "docId", new { }).ConfigureAwait(false);
}).ConfigureAwait(false);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="key-value-reads"><a class="anchor" href="#key-value-reads"></a>Key-Value Reads</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two ways to get a document, <code>GetAsync</code> and <code>GetOptionalAsync</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L171-L175">await _transactions.RunAsync(async ctx =&gt;
{
    var docId = "a-doc";
    var docOpt = await ctx.GetAsync(_collection, docId).ConfigureAwait(false);
}).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>GetAsync</code> will cause the transaction to fail with <code>TransactionFailedException</code> (after rolling back any changes, of course).
It is provided as a convenience method so the developer does not have to check for <code>null</code> if the document must exist for the transaction to succeed.</p>
</div>
<div class="paragraph">
<p>Gets will 'read your own writes', e.g. this will succeed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L182-L188">await _transactions.RunAsync(async ctx =&gt;
{
    var docId = "docId";
    _ = await ctx.InsertAsync(_collection, docId, new { }).ConfigureAwait(false);
    var doc = await ctx.GetAsync(_collection, docId).ConfigureAwait(false);
    Console.WriteLine((object) doc.ContentAs&lt;dynamic&gt;());
}).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="using-n1ql"><a class="anchor" href="#using-n1ql"></a>Using N1QL</h3>
<div class="paragraph">
<p>If you already use N1QL from the .NET SDK, then its use in transactions is very similar.
It returns the same <code>IQueryResult&lt;T&gt;</code> you are used to, and takes most of the same options.</p>
</div>
<div class="paragraph">
<p>You must take care to write <code>ctx.QueryAsync()</code> inside the lambda however, rather than <code>cluster.QueryAsync()</code> or <code>scope.QueryAsync()</code>.</p>
</div>
<div class="paragraph">
<p>An example of selecting some rows from the <code>travel-sample</code> bucket:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L484-L493">var st = "SELECT * FROM `travel-sample`.inventory.hotel WHERE country = $1";
var transactionResult = await transactions.RunAsync(async ctx =&gt; {
    IQueryResult&lt;object&gt; qr = await ctx.QueryAsync&lt;object&gt;(st,
        new TransactionQueryOptions().Parameter("United Kingdom"));

    await foreach (var result in qr.Rows)
    {
        Console.Out.WriteLine($"result = {result}", result);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rather than specifying the full "`travel-sample`.inventory.hotel" name each time, it is easier to pass a reference to the inventory <code>IScope</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L499-L508">IBucket travelSample = await cluster.BucketAsync("travel-sample");
IScope inventory = travelSample.Scope("inventory");

var transactionResult = await transactions.RunAsync(async ctx =&gt;
{
    var st = "SELECT * FROM `travel-sample`.inventory.hotel WHERE country = $1";
    IQueryResult&lt;object&gt; qr = await ctx.QueryAsync&lt;object&gt;(st,
        options: new TransactionQueryOptions().Parameter("United Kingdom"),
        scope: inventory);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example using a <code>IScope</code> for an UPDATE:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L516-L528">var hotelChain = "http://marriot%";
var country = "United States";

await transactions.RunAsync(async ctx =&gt; {
    var qr = await ctx.QueryAsync&lt;object&gt;(
        statement: "UPDATE hotel SET price = $price WHERE url LIKE $url AND country = $country",
        configure: options =&gt; options.Parameter("price", 99.99m)
                          .Parameter("url", hotelChain)
                          .Parameter("country", country),
        scope: inventory);

    Console.Out.WriteLine($"Records Updated = {qr?.MetaData.Metrics.MutationCount}");
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>And an example combining SELECTs and UPDATEs.
It&#8217;s possible to call regular C# methods from the lambda, as shown here, permitting complex logic to be performed.
Just remember that since the lambda may be called multiple times, so may the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L539-L555">await transactions.RunAsync(async ctx =&gt; {
    // Find all hotels of the chain
    IQueryResult&lt;Review&gt; qr = await ctx.QueryAsync&lt;Review&gt;(
        statement: "SELECT reviews FROM hotel WHERE url LIKE $1 AND country = $2",
        configure: options =&gt; options.Parameter(hotelChain).Parameter(country),
        scope: inventory);

    // This function (not provided here) will use a trained machine learning model to provide a
    // suitable price based on recent customer reviews.
    var updatedPrice = PriceFromRecentReviews(qr);

    // Set the price of all hotels in the chain
    await ctx.QueryAsync&lt;object&gt;(
        statement: "UPDATE hotel SET price = $1 WHERE url LIKE $2 AND country = $3",
            configure: options =&gt; options.Parameter(hotelChain, country, updatedPrice),
            scope: inventory);
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="read-your-own-writes"><a class="anchor" href="#read-your-own-writes"></a>Read Your Own Writes</h3>
<div class="paragraph">
<p>As with Key-Value operations, N1QL queries support Read Your Own Writes.</p>
</div>
<div class="paragraph">
<p>This example shows inserting a document and then selecting it again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L561-L568">await transactions.RunAsync(async ctx =&gt; {
    await ctx.QueryAsync&lt;object&gt;("INSERT INTO `default` VALUES ('doc', {'hello':'world'})", TransactionQueryConfigBuilder.Create());  <i class="conum" data-value="1"></i><b>(1)</b>

    // Performing a 'Read Your Own Write'
    var st = "SELECT `default`.* FROM `default` WHERE META().id = 'doc'"; <i class="conum" data-value="2"></i><b>(2)</b>
    IQueryResult&lt;object&gt; qr = await ctx.QueryAsync&lt;object&gt;(st, TransactionQueryConfigBuilder.Create());
    Console.Out.WriteLine($"ResultCount = {qr?.MetaData.Metrics.ResultCount}");
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The inserted document is only staged at this point. as the transaction has not yet committed.
Other transactions, and other non-transactional actors, will not be able to see this staged insert yet.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>But the SELECT can, as we are reading a mutation staged inside the same transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mixing-key-value-and-n1ql"><a class="anchor" href="#mixing-key-value-and-n1ql"></a>Mixing Key-Value and N1QL</h3>
<div class="paragraph">
<p>Key-Value operations and queries can be freely intermixed, and will interact with each other as you would expect.</p>
</div>
<div class="paragraph">
<p>In this example we insert a document with Key-Value, and read it with a SELECT.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L630-L637">await transactions.RunAsync(async ctx =&gt; {
    _ = await ctx.InsertAsync(collection, "doc", new { Hello = "world" }); <i class="conum" data-value="1"></i><b>(1)</b>

    // Performing a 'Read Your Own Write'
    var st = "SELECT `default`.* FROM `default` WHERE META().id = 'doc'"; <i class="conum" data-value="2"></i><b>(2)</b>
    var qr = await ctx.QueryAsync&lt;object&gt;(st);
    Console.Out.WriteLine($"ResultCount = {qr?.MetaData.Metrics.ResultCount}");
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>As with the 'Read Your Own Writes' example, here the insert is only staged, and so it is not visible to other transactions or non-transactional actors.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>But the SELECT can view it, as the insert was in the same transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="query-options"><a class="anchor" href="#query-options"></a>Query Options</h3>
<div class="paragraph">
<p>Query options can be provided via <code>TransactionQueryOptions</code>, which provides a subset of the options in the .NET SDK&#8217;s <code>QueryOptions</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L643-L646">await transactions.RunAsync(async ctx =&gt; {
    await ctx.QueryAsync&lt;object&gt;("INSERT INTO `default` VALUES ('doc', {'hello':'world'})",
            new TransactionQueryOptions().FlexIndex(true));
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The supported options are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Parameter</p>
</li>
<li>
<p>ScanConsistency</p>
</li>
<li>
<p>FlexIndex</p>
</li>
<li>
<p>Serializer</p>
</li>
<li>
<p>ClientContextId</p>
</li>
<li>
<p>ScanWait</p>
</li>
<li>
<p>ScanCap</p>
</li>
<li>
<p>PipelineBatch</p>
</li>
<li>
<p>PipelineCap</p>
</li>
<li>
<p>Readonly</p>
</li>
<li>
<p>AdHoc</p>
</li>
<li>
<p>Raw</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="n1ql-queries-with-sdk.html#query-options" class="xref page">QueryOptions documentation</a> for details on these.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L574-L597">var bulkLoadStatement = "&lt;a bulk-loading N1QL statement&gt;";

try
{
    SingleQueryTransactionResult&lt;object&gt; result = await transactions.QueryAsync&lt;object&gt;(bulkLoadStatement);

    IQueryResult&lt;object&gt; queryResult = result.QueryResult;
}
catch (TransactionCommitAmbiguousException e)
{
    Console.Error.WriteLine("Transaction possibly committed");
    foreach (var log in e.Result.Logs)
    {
        Console.Error.WriteLine(log);
    }
}
catch (TransactionFailedException e)
{
    Console.Error.WriteLine("Transaction did not reach commit point");
    foreach (var log in e.Result.Logs)
    {
        Console.Error.WriteLine(log);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also run a single query transaction against a particular <code>IScope</code> (these examples will exclude the full error handling for brevity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L605-L608">IBucket travelSample = await cluster.BucketAsync("travel-sample");
IScope inventory = travelSample.Scope("inventory");

await transactions.QueryAsync&lt;object&gt;(bulkLoadStatement, scope: inventory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>and configure it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L617-L623">// with the Builder pattern.
await transactions.QueryAsync&lt;object&gt;(bulkLoadStatement, SingleQueryTransactionConfigBuilder.Create()
    // Single query transactions will often want to increase the default timeout
    .ExpirationTime(TimeSpan.FromSeconds(360)));

// using the lambda style
await transactions.QueryAsync&lt;object&gt;(bulkLoadStatement, config =&gt; config.ExpirationTime(TimeSpan.FromSeconds(360)));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="committing-2"><a class="anchor" href="#committing-2"></a>Committing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Committing is automatic: if there is no explicit call to <code>ctx.CommitAsync()</code> at the end of the transaction logic callback, and no exception is thrown, it will be committed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L219-L226">var result = await _transactions.RunAsync(async (ctx) =&gt;
{
    var doc = await ctx.GetAsync(_collection, "anotherDoc").ConfigureAwait(false);
    var content = doc.ContentAs&lt;JObject&gt;();
    content.Add("transactions", "are awesome");

    await ctx.ReplaceAsync(doc, content).ConfigureAwait(false);
}).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As described above, as soon as the transaction is committed, all its changes will be atomically visible to reads from other transactions.
The changes will also be committed (or "unstaged") so they are visible to non-transactional actors, in an eventually consistent fashion.</p>
</div>
<div class="paragraph">
<p>Commit is final: after the transaction is committed, it cannot be rolled back, and no further operations are allowed on it.</p>
</div>
<div class="paragraph">
<p>An asynchronous cleanup process ensures that once the transaction reaches the commit point, it will be fully committed&#8201;&#8212;&#8201;even if the application crashes.</p>
</div>
<div class="paragraph">
<p>A complete version of this example is available on our <a href="https://github.com/couchbaselabs/couchbase-transactions-dotnet-examples">GitHub transactions examples page</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L234-L306">try
{
    await _transactions.RunAsync(async (ctx) =&gt;
    {
        _logger.LogInformation(
            "Starting transaction, player {playerId} is hitting monster {monsterId} for {damage} points of damage.",
            playerId, monsterId, damage);

        var monster = await ctx.GetAsync(_collection, monsterId).ConfigureAwait(false);
        var player = await ctx.GetAsync(_collection, playerId).ConfigureAwait(false);

        var monsterContent = monster.ContentAs&lt;JObject&gt;();
        var playerContent = player.ContentAs&lt;JObject&gt;();

        var monsterHitPoints = monsterContent.GetValue("hitpoints").ToObject&lt;int&gt;();
        var monsterNewHitPoints = monsterHitPoints - damage;

        _logger.LogInformation(
            "Monster {monsterId} had {monsterHitPoints} hitpoints, took {damage} damage, now has {monsterNewHitPoints} hitpoints.",
            monsterId, monsterHitPoints, damage, monsterNewHitPoints);

        if (monsterNewHitPoints &lt;= 0)
        {
            // Monster is killed.  The remove is just for demoing, and a more realistic example would set a
            // "dead" flag or similar.

            await ctx.RemoveAsync(monster).ConfigureAwait(false);

            // The player earns experience for killing the monster
            var experienceForKillingMonster =
                monsterContent.GetValue("experienceWhenKilled").ToObject&lt;int&gt;();
            var playerExperience = playerContent.GetValue("experiance").ToObject&lt;int&gt;();
            var playerNewExperience = playerExperience + experienceForKillingMonster;
            var playerNewLevel = CalculateLevelForExperience(playerNewExperience);

            _logger.LogInformation(
                "Monster {monsterId} was killed.  Player {playerId} gains {experienceForKillingMonster} experience, now has level {playerNewLevel}.",
                monsterId, playerId, experienceForKillingMonster, playerNewLevel);

            playerContent["experience"] = playerNewExperience;
            playerContent["level"] = playerNewLevel;

            await ctx.ReplaceAsync(player, playerContent).ConfigureAwait(false);
        }
        else
        {
            _logger.LogInformation("Monster {monsterId} is damaged but alive.", monsterId);

            // Monster is damaged but still alive
            monsterContent.Add("hitpoints", monsterNewHitPoints);

            await ctx.ReplaceAsync(monster, monsterContent).ConfigureAwait(false);
        }

        _logger.LogInformation("About to commit transaction");

    }).ConfigureAwait(false);
}
catch (TransactionCommitAmbiguousException e)
{
    _logger.LogWarning("Transaction possibly committed:{0}{1}", Environment.NewLine, e);
}
catch (TransactionFailedException e)
{
    // The operation timed out (the default timeout is 15 seconds) despite multiple attempts to commit the
    // transaction logic.   Both the monster and the player will be untouched.

    // This situation should be very rare.  It may be reasonable in this situation to ignore this particular
    // failure, as the downside is limited to the player experiencing a temporary glitch in a fast-moving MMO.

    // So, we will just log the error
    _logger.LogWarning("Transaction did not reach commit:{0}{1}", Environment.NewLine, e);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rollback"><a class="anchor" href="#rollback"></a>Rollback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If an exception is thrown, either by the application from the lambda, or by the transactions library, then that attempt is rolled back.
The transaction logic may or may not be retried, depending on the exception.</p>
</div>
<div class="paragraph">
<p>If the transaction is not retried then it will throw a <code>TransactionFailedException</code> exception, and its <code>Cause</code> property can be used for more details on the failure.</p>
</div>
<div class="paragraph">
<p>The application can use this to signal why it triggered a rollback, as so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L340-L363">
try
{
    await _transactions.RunAsync(async ctx =&gt;
    {
        var customer = await ctx.GetAsync(_collection, "customer-name").ConfigureAwait(false);

        if (customer.ContentAs&lt;dynamic&gt;().balance &lt; costOfItem) throw new BalanceInsufficientException();
        // else continue transaction
    }).ConfigureAwait(false);
}
catch (TransactionCommitAmbiguousException e)
{
    // This exception can only be thrown at the commit point, after the
    // BalanceInsufficient logic has been passed, so there is no need to
    // check getCause here.
    Console.Error.WriteLine("Transaction possibly committed");
    Console.Error.WriteLine(e);
}
catch (TransactionFailedException e)
{
    Console.Error.WriteLine("Transaction did not reach commit point");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transaction can also be explicitly rolled back:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L321-L329">await _transactions.RunAsync(async (ctx) =&gt; {
    var customer = await ctx.GetAsync(_collection, "customer-name").ConfigureAwait(false);

    if (customer.ContentAs&lt;dynamic&gt;().balance &lt; costOfItem)
    {
        await ctx.RollbackAsync().ConfigureAwait(false);
    }
    // else continue transaction
}).ConfigureAwait(false);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, if <code>ctx.RollbackAsync()</code> is reached, then the transaction will be regarded as successfully rolled back and no TransactionFailed will be thrown.</p>
</div>
<div class="paragraph">
<p>After a transaction is rolled back, it cannot be committed, no further operations are allowed on it, and the library will not try to automatically commit it at the end of the code block.</p>
</div>
<div class="paragraph">
<p>There can be situations where total failure is indicated to the application via errors.
These situations include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any error thrown by a transaction lambda, either deliberately or through an application logic bug.</p>
</li>
<li>
<p>Attempting to insert a document that already exists.</p>
</li>
<li>
<p>Calling <code>ctx.GetAsync()</code> on a document key that does not exist (if the resultant exception is not caught).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once one of these errors occurs, the current attempt is irrevocably failed (though the transaction may retry the lambda to make a new attempt).
It is not possible for the application to catch the failure and continue (with the exception of <code>ctx.GetAsync()</code> raising an error).
Once a failure has occurred, all other operations tried in this attempt (including commit) will instantly fail.</p>
</div>
<div class="paragraph">
<p>Transactions, as they are multi-stage and multi-document, also have a concept of partial success or failure.
This is signalled to the application through the <code>TransactionResult.UnstagingComplete</code> property, described later.</p>
</div>
<div class="paragraph">
<p>There are three exceptions that transactions can raise to an application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TransactionFailedException</code></p>
</li>
<li>
<p><code>TransactionExpiredException</code></p>
</li>
<li>
<p><code>TransactionCommitAmbiguousException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are three exceptions that Couchbase transactions can raise to the application:
<code>TransactionFailedException</code>, <code>TransactionExpiredException</code> and <code>TransactionCommitAmbiguousException</code>.
All exceptions derive from <code>TransactionFailedException</code> for backwards-compatibility purposes.</p>
</div>
<div class="sect2">
<h3 id="transactionfailedexception-and-transactionexpiredexception"><a class="anchor" href="#transactionfailedexception-and-transactionexpiredexception"></a>TransactionFailedException and TransactionExpiredException</h3>
<div class="paragraph">
<p>The transaction definitely did not reach the commit point.
<code>TransactionFailedException</code> indicates a fast-failure whereas <code>TransactionExpiredException</code> indicates that retries were made until the timeout was reached, but this distinction is not normally important to an application and generally <code>TransactionExpiredException</code> does not need to be handled individually.</p>
</div>
<div class="paragraph">
<p>Either way, an attempt will have been made to rollback all changes.
This attempt may or may not have been successful, but the results of this will have no impact on the protocol or other actors.
No changes from the transaction will be visible, both to transactional and non-transactional actors.</p>
</div>
<div class="sect3">
<h4 id="handling"><a class="anchor" href="#handling"></a>Handling</h4>
<div class="paragraph">
<p>Generally, debugging exactly why a given transaction failed requires review of the logs, so it is suggested that the application log these on failure.
The application may want to try the transaction again later.
Alternatively, if transaction completion time is not a priority, then transaction timeouts (which default to 15 seconds) can be extended across the board through <code>TransactionConfigBuilder</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L64-L66">Transactions transactions = Transactions.Create(_cluster, TransactionConfigBuilder.Create()
    .ExpirationTime(TimeSpan.FromSeconds(120))
    .Build());</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will allow the protocol more time to get past any transient failures (for example, those caused by a cluster rebalance).
The tradeoff to consider with longer timeouts, is that documents that have been staged by a transaction are effectively locked from modification from other transactions, until the timeout has been reached.</p>
</div>
<div class="paragraph">
<p>Note that the timeout is not guaranteed to be followed precisely.
For example, if the application were to do a long blocking operation inside the lambda (which should be avoided), then timeout can only trigger after this finishes.
Similarly, if the transaction attempts a key-value operation close to the timeout, and that key-value operation times out, then the transaction timeout may be exceeded.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transactioncommitambiguousexception"><a class="anchor" href="#transactioncommitambiguousexception"></a>TransactionCommitAmbiguousException</h3>
<div class="paragraph">
<p>Each transaction has a 'single point of truth' that is updated atomically to reflect whether it is committed.</p>
</div>
<div class="paragraph">
<p>However, it is not always possible for the protocol to become 100% certain that the operation was successful, before the transaction expires.
This potential ambiguity is unavoidable in any distributed system; a classic example is a network failure happening just after an operation was sent from a client to a server.
The client will not get a response back and cannot know if the server received and executed the operation.</p>
</div>
<div class="paragraph">
<p>The ambiguity is particularly important at the point of the atomic commit, as the transaction may or may not have reached the commit point.  Couchbase transactions will raise <code>TransactionCommitAmbiguousException</code> to indicate this state.
It should be rare to receive this error.</p>
</div>
<div class="paragraph">
<p>If the transaction had in fact successfully reached the commit point, then the transaction will be fully completed ("unstaged") by the asynchronous cleanup process at some point in the future.
With default settings this will usually be within a minute, but whatever underlying fault has caused the <code>TransactionCommitAmbiguousException</code> may lead to it taking longer.</p>
</div>
<div class="paragraph">
<p>If the transaction had not in fact reached the commit point, then the asynchronous cleanup process will instead attempt to roll it back at some point in the future.</p>
</div>
<div class="sect3">
<h4 id="handling-2"><a class="anchor" href="#handling-2"></a>Handling</h4>
<div class="paragraph">
<p>This error can be challenging for an application to handle.
As with <code>TransactionFailedException</code> it is recommended that it at least writes any logs from the transaction, for future debugging.
It may wish to retry the transaction at a later point, or extend transactional timeouts (as detailed above) to give the protocol additional time to resolve the ambiguity.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transactionresult-unstagingcomplete"><a class="anchor" href="#transactionresult-unstagingcomplete"></a>TransactionResult.UnstagingComplete</h3>
<div class="paragraph">
<p>This boolean flag indicates whether all documents were able to be unstaged (committed).</p>
</div>
<div class="paragraph">
<p>For most use-cases it is not an issue if it is false.
All transactional actors will still read all the changes from this transaction, as though it had committed fully.
The cleanup process is asynchronously working to complete the commit, so that it will be fully visible to non-transactional actors.</p>
</div>
<div class="paragraph">
<p>The flag is provided for those rare use-cases where the application requires the commit to be fully visible to non-transactional actors, before it may continue.
In this situation the application can raise an error here, or poll all documents involved until they reflect the mutations.</p>
</div>
<div class="paragraph">
<p>If you regularly see this flag false, consider increasing the transaction timeout to reduce the possibility that the transaction times out during the commit.</p>
</div>
<div class="paragraph">
<p>Similar to <code>TransactionResult</code>, <code>SingleQueryTransactionResult</code> also has an <code>UnstagingComplete</code> property.</p>
</div>
</div>
<div class="sect2">
<h3 id="full-error-handling-example"><a class="anchor" href="#full-error-handling-example"></a>Full Error Handling Example</h3>
<div class="paragraph">
<p>Pulling all of the above together, this is the suggested best practice for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L370-L413">try
{
    var result = await _transactions.RunAsync(async (ctx) =&gt; {
        // ... transactional code here ...
    });

    // The transaction definitely reached the commit point. Unstaging
    // the individual documents may or may not have completed

    if (result.UnstagingComplete)
    {
        // Operations with non-transactional actors will want
        // unstagingComplete() to be true.
        await _cluster.QueryAsync&lt;dynamic&gt;(" ... N1QL ... ",
            new QueryOptions()).ConfigureAwait(false);

        var documentKey = "a document key involved in the transaction";
        var getResult = await _collection.GetAsync(documentKey).ConfigureAwait(false);
    }
    else
    {
        // This step is completely application-dependent.  It may
        // need to throw its own exception, if it is crucial that
        // result.unstagingComplete() is true at this point.
        // (Recall that the asynchronous cleanup process will
        // complete the unstaging later on).
    }
}
catch (TransactionCommitAmbiguousException err)
{
    // The transaction may or may not have reached commit point
    Console.Error.WriteLine("Transaction returned TransactionCommitAmbiguous and" +
            " may have succeeded, logs:");

    // Of course, the application will want to use its own logging rather
    // than Console.Error
    Console.Error.WriteLine(err);
}
catch (TransactionFailedException err)
{
    // The transaction definitely did not reach commit point
    Console.Error.WriteLine("Transaction failed with TransactionFailed, logs:");
    Console.Error.WriteLine(err);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Transactions will try to clean up after themselves in the advent of failures.
However, there are situations that inevitably created failed, or 'lost' transactions, such as an application crash.</p>
</div>
<div class="paragraph">
<p>This requires an asynchronous cleanup task, described in this section.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="background-cleanup"><a class="anchor" href="#background-cleanup"></a>Background Cleanup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Creating the <code>Transactions</code> object spawns a background cleanup task, whose job it is to periodically scan for expired transactions and clean them up.
It does this by scanning a subset of the Active Transaction Record (ATR) transaction metadata documents, on each bucket.
As you&#8217;ll recall from <a href="#mechanics">earlier</a>, an entry for each transaction attempt exists in one of these documents.
They are removed during cleanup or at some time after successful completion.</p>
</div>
<div class="paragraph">
<p>The default settings are tuned to find expired transactions reasonably quickly, while creating negligible impact from the background reads required by the scanning process.
To be exact, with default settings it will generally find expired transactions within 60 seconds, and use less than 20 reads per second, per collection of metadata documents being checked.
This is unlikely to impact performance on any cluster, but the settings may be <a href="#tuning-cleanup">tuned</a> as desired.</p>
</div>
<div class="paragraph">
<p>All applications connected to the same cluster and running transactions will share in the cleanup, via a low-touch communication protocol on the <code>_txn:client-record</code> metadata document that will be created in each collection in the cluster involved with transaction metadata.
This document is visible and should not be modified externally as it is maintained automatically.
All ATRs will be distributed between all cleanup clients, so increasing the number of applications will not increase the reads required for scanning.</p>
</div>
<div class="paragraph">
<p>An application may cleanup transactions created by another application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to understand that if an application is not running, then cleanup is not running.
This is particularly relevant to developers running unit tests or similar.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="tuning-cleanup"><a class="anchor" href="#tuning-cleanup"></a>Configuring Cleanup</h3>
<div class="paragraph">
<p>The cleanup settings can be configured as so:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CleanupWindow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60 seconds</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This determines how long a cleanup 'run' is; that is, how frequently this client will check its subset of ATR documents.  It is perfectly valid for the application to change this setting, which is at a conservative default.  Decreasing this will cause expiration transactions to be found more swiftly (generally, within this cleanup window), with the tradeoff of increasing the number of reads per second used for the scanning process.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CleanupLostAttempts</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the thread that takes part in the distributed cleanup process described above, that cleans up expired transactions created by any client.  It is strongly recommended that it is left enabled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CleanupClientAttempts</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This thread is for cleaning up transactions created just by this client.  The client will preferentially aim to send any transactions it creates to this thread, leaving transactions for the distributed cleanup process only when it is forced to (for example, on an application crash).  It is strongly recommended that it is left enabled.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logging"><a class="anchor" href="#logging"></a>Logging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To aid troubleshooting, each transaction maintains a list of log entries, which can be logged on failure like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L420-L434">try
{
    var result = await transactions.RunAsync(async ctx =&gt; {
        // ... transactional code here ...
    });
}
catch (TransactionFailedException err)
{
    // ... log the error as you normally would
    // then include the logs
    foreach (var logLine in err.Result.Logs)
    {
        Console.Error.WriteLine(logLine);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A failed transaction can involve dozens, even hundreds, of lines of logging, so the application may prefer to write failed transactions into a separate file.</p>
</div>
<div class="paragraph">
<p>Please see the <a href="collecting-information-and-logging.html" class="xref page">.NET SDK logging documentation</a> for details.</p>
</div>
<div class="paragraph">
<p>Here is an example of configuring a <code>Microsoft.Extensions.Logging.ILoggingFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L441-L473">//Logging dependencies
var services = new ServiceCollection();
services.AddLogging(builder =&gt;
{
    builder.AddFile(AppContext.BaseDirectory);
    builder.AddConsole();
});
await using var provider = services.BuildServiceProvider();
var loggerFactory = provider.GetService&lt;ILoggerFactory&gt;();
var logger = loggerFactory.CreateLogger&lt;Program&gt;();

//create the transactions object and add the ILoggerFactory
var transactions = Transactions.Create(_cluster,
    TransactionConfigBuilder.Create().LoggerFactory(loggerFactory));
try
{
    var result = await transactions.RunAsync(async ctx =&gt; {
        // ... transactional code here ...
    });
}
catch (TransactionCommitAmbiguousException err)
{
    // The transaction may or may not have reached commit point
    logger.LogInformation("Transaction returned TransactionCommitAmbiguous and" +
                " may have succeeded, logs:");
    Console.Error.WriteLine(err);
}
catch (TransactionFailedException err)
{
    // The transaction definitely did not reach commit point
    logger.LogInformation("Transaction failed with TransactionFailed, logs:");
    Console.Error.WriteLine(err);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As described earlier, transactions automatically create and use metadata documents.
By default, these are created in the default collection of the bucket of the first mutated document in the transaction.
Optionally, you can instead specify a collection to store the metadata documents.
Most users will not need to use this functionality, and can continue to use the default behavior.
They are provided for these use-cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The metadata documents contain, for documents involved in each transaction, the document&#8217;s key and the name of the bucket, scope and collection it exists on.
In some deployments this may be sensitive data.</p>
</li>
<li>
<p>You wish to remove the default collections.
Before doing this, you should ensure that all existing transactions using metadata documents in the default collections have finished.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Custom metadata collections are enabled with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-csharp hljs" data-lang="csharp" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-dotnet//modules/howtos/examples/TransactionsExample.cs#L652-L654">ICouchbaseCollection metadataCollection = null; // this is a Collection opened by your code earlier
Transactions transactionsWithCustomMetadataCollection = Transactions.Create(cluster,
        TransactionConfigBuilder.Create().MetadataCollection(metadataCollection));</code></pre>
</div>
</div>
<div class="paragraph">
<p>When specified:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any transactions created from this <code>Transactions</code> object, will create and use metadata in that collection.</p>
</li>
<li>
<p>The asynchronous cleanup started by this <code>Transactions</code> object will be looking for expired transactions only in this collection.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to ensure that this application has RBAC data read and write privileges to it, and should not delete the collection subsequently as it can interfere with existing transactions.
You can use an existing collection or create a new one.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="further-reading"><a class="anchor" href="#further-reading"></a>Further Reading</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>There&#8217;s plenty of explanation about how Transactions work in Couchbase in our <a href="../../../server/7.1/learn/data/transactions.html" class="xref page">Transactions documentation</a>.</p>
</li>
<li>
<p>You can find further code examples on our <a href="https://github.com/couchbaselabs/couchbase-transactions-dotnet-examples">transactions examples repository</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span> 2022 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script src="../../../_/js/site-navigation-data.js"></script>
<script id="page-navigation-group" type="application/json">
{"title":"SDKs","components":["dotnet-sdk","c-sdk","go-sdk","java-sdk","nodejs-sdk","php-sdk","python-sdk","ruby-sdk","scala-sdk","cxx-txns"],"url":"/home/sdk.html","latestVersions":{"dotnet-sdk":"3.3","c-sdk":"3.3","go-sdk":"2.5","java-sdk":"3.3","nodejs-sdk":"4.1","php-sdk":"4.0","python-sdk":"4.0","ruby-sdk":"3.3","scala-sdk":"1.3","cxx-txns":"DOC-9740"}}
</script>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
