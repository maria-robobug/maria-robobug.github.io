<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Distributed Transactions from the Python SDK | Couchbase Docs (Local)</title>
<link rel="canonical" href="https://maria-robobug.github.io/python-sdk/4.0/howtos/distributed-acid-transactions-from-the-sdk.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="A practical guide to using Couchbase distributed ACID transactions with the Python SDK.">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="python-sdk">
<meta name="dcterms.identifier" content="4.0">
<meta name="page-url" content="/python-sdk/4.0/howtos/distributed-acid-transactions-from-the-sdk.html">
<meta name="generator" content="Antora 3.0.1">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://maria-robobug.github.io/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="https://maria-robobug.github.io/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../cloud/index.html">
                      Capella
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../cloud-native-database/index.html">
                      Cloud-Native
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="2">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/pages/distributed-acid-transactions-from-the-sdk.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../hello-world/overview.html">Python SDK</a></li>
<li class="crumb">Advanced Data Operations</li>
<li class="crumb"><a href="distributed-acid-transactions-from-the-sdk.html">Distributed ACID Transactions</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Distributed Transactions from the Python SDK</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
A practical guide to using Couchbase distributed ACID transactions with the Python SDK.
</blockquote>
</div>
<div class="paragraph">
<p>Couchbase Distributed <a href="../../../server/7.1/learn/data/transactions.html#overview" class="xref page">ACID (atomic, consistent, isolated, and durable)</a> Transactions allow applications to perform a series of database operations as a single unit&#8201;&#8212;&#8201;meaning operations are either committed together or all undone.
Transactions are distributed and work across multiple documents, buckets, scopes, and collections, which can reside on multiple nodes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="requirements"><a class="anchor" href="#requirements"></a>Requirements</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Couchbase Server 6.6.1 or above.</p>
</li>
<li>
<p>Couchbase Python SDK 4.0.0 or above.
.Single Node Cluster</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>When using a single node cluster (for example, during development), the default number of replicas for a newly created bucket is <strong>1</strong>.
If left at this default, all key-value writes performed with durability will fail with a <code>DurabilityImpossibleException</code>.
In turn, this will cause all transactions (which perform all key-value writes durably) to fail.
This setting can be changed via:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="../../../cloud/clusters/data-service/manage-buckets.html#add-bucket" class="xref page">Capella UI</a></p>
</li>
<li>
<p><a href="../../../server/7.1/manage/manage-buckets/create-bucket.html#couchbase-bucket-settings" class="xref page">Couchbase Server UI</a></p>
</li>
<li>
<p><a href="../../../server/7.1/cli/cbcli/couchbase-cli-bucket-create.html#options" class="xref page">Command Line</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the bucket already exists, then the server needs to be rebalanced for the setting to take affect.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase transactions require no additional components or services to be configured.
Simply <code>pip install</code> the most recent version of the SDK.
You may, on occasion, need to import some enumerations for particular settings, but in basic cases nothing is needed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transactions can optionally be globally configured when configuring the <code>Cluster</code>.
For example, if you want to change the level of durability which must be attained, this can be configured as part of the connect options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L21-L26">opts = ClusterOptions(authenticator=PasswordAuthenticator("Administrator", "password"),
                      transaction_config=TransactionConfig(
                          durability=ServerDurability(DurabilityLevel.PERSIST_TO_MAJORITY))
                      )

cluster = Cluster.connect('couchbase://localhost', opts)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration will perform all writes with the durability setting <code>Majority</code>, ensuring that each write is available in-memory on the majority of replicas before the transaction continues.
There are two higher durability settings available that will additionally wait for all mutations to be written to physical storage on either the active or the majority of replicas, before continuing.
This further increases safety, at a cost of additional latency.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
A level of <code>None</code> is present but its use is discouraged and unsupported.
If durability is set to <code>None</code>, then ACID semantics are not guaranteed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To create a transaction, an application must supply its logic inside a <code>{lambda}</code>, including any conditional logic required.
Once the {lambda} has successfully run to conclusion, the transaction will be automatically committed.
If at any point an error occurs, the transaction will rollback and the {lambda} may run again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L70-L88">def txn_logic_ex(ctx  # type: AttemptContext
                 ):
    """
    … Your transaction logic here …
    """

try:
    """
    'txn_logic_ex' is a Python closure that takes an AttemptContext. The
    AttemptContext permits getting, inserting, removing and replacing documents,
    performing N1QL queries, etc.

    Committing is implicit at the end of the closure.
    """
    cluster.transactions.run(txn_logic_ex)
except TransactionFailed as ex:
    print(f'Transaction did not reach commit point.  Error: {ex}')
except TransactionCommitAmbiguous as ex:
    print(f'Transaction possibly committed.  Error: {ex}')</code></pre>
</div>
</div>
<div id="lambda-ops" class="paragraph">
<p>The transaction lambda gets passed a <code>AttemptContext</code> object&#8201;&#8212;&#8201;generally referred to as <code>ctx</code> in these examples.
Since the {lambda} could be rerun multiple times, it is important that it does not contain any side effects.
In particular, you should never perform regular operations on a <code>Collection</code>, such as <code>collection.insert()</code>, inside the lambda.
Such operations may be performed multiple times, and will not be performed transactionally.
Instead, you should perform these operations through the <code>ctx</code> object, e.g. <code>ctx.insert()</code>.</p>
</div>
<div class="paragraph">
<p>The result of a transaction is represented by a <code>TransactionResult</code> object, which can be used to expose debugging and logging information to help track what happened during a transaction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py">inventory = cluster.bucket("travel-sample").scope("inventory")

def txn_example(ctx):
    # insert doc
    ctx.insert(collection, 'doc-a', {})

    # get a doc
    doc_a = ctx.get(collection, 'doc-a')

    # replace a doc
    doc_b = ctx.get(collection, 'doc-b')
    content = doc_b.content_as[dict]
    content['transactions'] = 'are awesome!'
    ctx.replace(doc_b, content)

    # remove a doc
    doc_c = ctx.get(collection, 'doc-c')
    ctx.remove(doc_c)

    query_str = 'SELECT * FROM `travel-sample`.inventory.hotel WHERE country = "United Kingdom" LIMIT 2;'
    res = ctx.query(query_str)
    rows = [r for r in res.rows()]

    query_str = 'UPDATE `travel-sample`.inventory.route SET airlineid = "airline_137" WHERE airline = "AF"'
    res = ctx.query(query_str)
    rows = [r for r in res.rows()]

try:
    cluster.transactions.run(txn_example)
except TransactionFailed as ex:
    print(f'Transaction did not reach commit point.  Error: {ex}')
except TransactionCommitAmbiguous as ex:
    print(f'Transaction possibly committed.  Error: {ex}')</code></pre>
</div>
</div>
<div class="paragraph">
<p>A core idea of Couchbase transactions is that an application supplies the logic for the transaction inside a <em>lambda</em>, including any conditional logic required, and the transaction is then automatically committed.
If a transient error occurs, such as a temporary conflict with another transaction, then the transaction will rollback what has been done so far and run the lambda again.
The application does not have to do these retries and error handling itself.</p>
</div>
<div class="paragraph">
<p>Each run of the lambda is called an <code>attempt</code>, inside an overall <code>transaction</code>.</p>
</div>
<div class="sect2">
<h3 id="active-transaction-record-entries"><a class="anchor" href="#active-transaction-record-entries"></a>Active Transaction Record Entries</h3>
<div class="paragraph">
<p>The first mechanic is that each of these attempts adds an entry to a metadata document in the Couchbase cluster.
These metadata documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Are named Active Transaction Records, or ATRs.</p>
</li>
<li>
<p>Are created and maintained automatically.</p>
</li>
<li>
<p>Begin with <code>_txn:atr-</code>.</p>
</li>
<li>
<p>Each contain entries for multiple attempts.</p>
</li>
<li>
<p>Are viewable, and <em>should not be modified externally</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each such ATR entry stores some metadata and, crucially, whether the attempt has committed or not.
In this way, the entry acts as the single point of truth for the transaction, which is essential for providing an 'atomic commit' during reads.</p>
</div>
</div>
<div class="sect2">
<h3 id="staged-mutations"><a class="anchor" href="#staged-mutations"></a>Staged Mutations</h3>
<div class="paragraph">
<p>The second mechanic is that mutating a document inside a transaction, does not directly change the body of the document.
Instead, the post-transaction version of the document is staged alongside the document (technically in its <a href="../concept-docs/xattr.html" class="xref page">extended attributes (XATTRs)</a>).
In this way, all changes are invisible to all parts of Couchbase until the commit point is reached.</p>
</div>
<div class="paragraph">
<p>These staged document changes effectively act as a lock against other transactions trying to modify the document, preventing write-write conflicts.</p>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>Cleanup</h3>
<div class="paragraph">
<p>There are safety mechanisms to ensure that leftover staged changes from a failed transaction cannot block live transactions indefinitely.
These include an asynchronous cleanup process that is started with the first transaction, and scans for expired transactions created by any application, on the relevant collections.</p>
</div>
<div class="paragraph">
<p>The cleanup process is detailed in the <a href="#concept-docs:transactions-cleanup.adoc" class="xref unresolved">concept-docs:transactions-cleanup.adoc</a> page.</p>
</div>
</div>
<div class="sect2">
<h3 id="committing"><a class="anchor" href="#committing"></a>Committing</h3>
<div class="paragraph">
<p>Only once the lambda has successfully run to conclusion, will the attempt be committed.
This updates the ATR entry, which is used as a signal by transactional actors to use the post-transaction version of a document from its XATTRs.
Hence, updating the ATR entry is an 'atomic commit' switch for the transaction.</p>
</div>
<div class="paragraph">
<p>After this commit point is reached, the individual documents will be committed (or "unstaged").
This provides an eventually consistent commit for non-transactional actors.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="key-value-mutations"><a class="anchor" href="#key-value-mutations"></a>Key-Value Mutations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="replacing"><a class="anchor" href="#replacing"></a>Replacing</h3>
<div class="paragraph">
<p>Replacing a document requires a <code>ctx.get()</code> call first.
This is necessary so the transaction can check that the document is not involved in another transaction.
If it is, then the transaction will handle this at the <code>ctx.replace()</code> point.
Generally, this involves rolling back what has been done so far, and retrying the lambda.
Handling errors should be done through try/except as in the example above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L182-L188">def txn_logic(ctx):
    doc = ctx.get(collection, key)
    content = doc.content_as[dict]
    content['transactions'] = 'are awesome!'
    ctx.replace(doc, content)

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="removing"><a class="anchor" href="#removing"></a>Removing</h3>
<div class="paragraph">
<p>As with replaces, removing a document requires a <code>ctx.get()</code> call first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L194-L198">def txn_logic(ctx):
    doc = ctx.get(collection, key)
    ctx.remove(doc)

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inserting"><a class="anchor" href="#inserting"></a>Inserting</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L204-L207">def txn_logic(ctx):
    ctx.insert(collection, key, content)

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="key-value-reads"><a class="anchor" href="#key-value-reads"></a>Key-Value Reads</h2>
<div class="sectionbody">
<div class="paragraph">
<p>From a transaction context you may get a document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L213-L217">def txn_logic(ctx):
    doc = ctx.get(collection, key)
    doc_content = doc.content_as[dict]

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get</code> may cause the transaction to fail with <code>TransactionFailed</code> (after rolling back any changes, of course).
It is provided as a convenience method so the developer does not have to check the <code>Optional</code> if the document must exist for the transaction to succeed.</p>
</div>
<div class="paragraph">
<p>Gets will 'read your own writes', e.g. this will succeed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L223-L228">def txn_logic(ctx):
    ctx.insert(collection, key, content)
    doc = ctx.get(collection, key)
    doc_content = doc.content_as[dict]

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="using-n1ql"><a class="anchor" href="#using-n1ql"></a>Using N1QL</h3>
<div class="paragraph">
<p>If you already use N1QL from the Python SDK, then its use in transactions is very similar.
It returns the same <code>QueryResult</code> you are used to, and takes most of the same options.</p>
</div>
<div class="paragraph">
<p>You must take care to write <code>ctx.query()</code> inside the lambda however, rather than <code>cluster.query()</code> or <code>scope.query()</code>.</p>
</div>
<div class="paragraph">
<p>An example of selecting some rows from the <code>travel-sample</code> bucket:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L234-L239">def txn_select(ctx):
    query_str = 'SELECT * FROM `travel-sample`.inventory.hotel WHERE country = "United Kingdom" LIMIT 2;'
    res = ctx.query(query_str)
    rows = [r for r in res.rows()]

cluster.transactions.run(txn_select)</code></pre>
</div>
</div>
<div class="paragraph">
<p>And an example combining SELECTs and UPDATEs.
It&#8217;s possible to call regular Python functions from the lambda, as shown here, permitting complex logic to be performed.
Just remember that since the lambda may be called multiple times, so may the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L271-L284">def txn_complex(ctx):
    # find all hotels of the chain
    res = ctx.query(
        'SELECT reviews FROM `travel-sample`.inventory.hotel WHERE url = "http://marriot%" AND country = "United States"')

    # This function (not provided here) will use a trained machine learning model to provide a
    # suitable price based on recent customer reviews.
    updated_price = price_from_recent_reviews(res)

    # Set the price of all hotels in the chain
    query_str = f'UPDATE `travel-sample`.inventory.hotel SET price = {updated_price} WHERE url LIKE "http://marriot%" AND country = "United States"'
    ctx.query(query_str)

cluster.transactions.run(txn_complex)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="read-your-own-writes"><a class="anchor" href="#read-your-own-writes"></a>Read Your Own Writes</h3>
<div class="paragraph">
<p>As with Key-Value operations, N1QL queries support Read Your Own Writes.</p>
</div>
<div class="paragraph">
<p>This example shows inserting a document and then selecting it again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L290-L296">def txn_logic(ctx):
    ctx.query(
        "INSERT INTO `travel-sample` VALUES ('doc', {'hello':'world'})")  <i class="conum" data-value="1"></i><b>(1)</b>
    query_str = "SELECT hello FROM `travel-sample` WHERE META().id = 'doc'"  <i class="conum" data-value="2"></i><b>(2)</b>
    res = ctx.query(query_str)

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The inserted document is only staged at this point, as the transaction has not yet committed.
Other transactions, and other non-transactional actors, will not be able to see this staged insert yet.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>But the SELECT can, as we are reading a mutation staged inside the same transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mixing-key-value-and-n1ql"><a class="anchor" href="#mixing-key-value-and-n1ql"></a>Mixing Key-Value and N1QL</h3>
<div class="paragraph">
<p>Key-Value operations and queries can be freely intermixed, and will interact with each other as you would expect.</p>
</div>
<div class="paragraph">
<p>In this example we insert a document with Key-Value, and read it with a SELECT.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L302-L309">def txn_logic(ctx):
    collection = cluster.defaultCollection()
    ctx.insert(collection, 'doc-greeting',
               {'greeting': 'hello world'})  <i class="conum" data-value="1"></i><b>(1)</b>
    query_str = "SELECT greeting FROM `travel-sample` WHERE META().id = 'doc-greeting'"  <i class="conum" data-value="2"></i><b>(2)</b>
    res = ctx.query(query_str)

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>As with the 'Read Your Own Writes' example, here the insert is only staged, and so it is not visible to other transactions or non-transactional actors.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>But the SELECT can view it, as the insert was in the same transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="query-options"><a class="anchor" href="#query-options"></a>Query Options</h3>
<div class="paragraph">
<p>Query options can be provided via <code>TransactionQueryOptions</code>, which provides a subset of the options in the Python SDK&#8217;s <code>QueryOptions</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L315-L323">def txn_logic(ctx):
    res = ctx.query(
        "INSERT INTO `travel-sample` VALUES ('doc-abc', {'hello':'world'})",
        TransactionQueryOptions(
            profile=QueryProfile.TIMINGS
        )
    )

cluster.transactions.run(txn_logic)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of the supported options are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>scan_consistency</p>
</li>
<li>
<p>client_context_id</p>
</li>
<li>
<p>scan_wait</p>
</li>
<li>
<p>scan_cap</p>
</li>
<li>
<p>pipeline_batch</p>
</li>
<li>
<p>pipeline_cap</p>
</li>
<li>
<p>profile</p>
</li>
<li>
<p>read_only</p>
</li>
<li>
<p>adhoc</p>
</li>
<li>
<p>raw</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="n1ql-queries-with-sdk.html#query-options" class="xref page">QueryOptions documentation</a> for details on these.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L329-L339">bulk_load_statement = ""  # a bulk-loading N1QL statement not provided here

def txn_logic(ctx):
    ctx.query(bulk_load_statement)

try:
    cluster.transactions.run(txn_logic)
except TransactionFailed as ex:
    print(f'Transaction did not reach commit point.  Error: {ex}')
except TransactionCommitAmbiguous as ex:
    print(f'Transaction possibly committed.  Error: {ex}')</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="committing-2"><a class="anchor" href="#committing-2"></a>Committing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Committing is automatic at the end of the code block with the transaction context.
If no exception is thrown, it will be committed.
If you want to rollback the transaction, simply throw an exception.
Transactions may rollback from the transaction logic itself, various failure conditions, or from your application logic by throwing an exception.</p>
</div>
<div class="paragraph">
<p>As soon as the transaction is committed, all its changes will be atomically visible to reads from other transactions.
The changes will also be committed (or "unstaged") so they are visible to non-transactional actors, in an eventually consistent fashion.</p>
</div>
<div class="paragraph">
<p>Commit is final: after the transaction is committed, it cannot be rolled back, and no further operations are allowed on it.</p>
</div>
<div class="paragraph">
<p>An asynchronous cleanup process ensures that once the transaction reaches the commit point, it will be fully committed - even if the application crashes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L356-L400">def player_hits_monster(damage, player_id, monster_id, cluster, collection):
    try:
        def txn_logic(ctx):
            monster_doc = (ctx.get(collection, monster_id)
                           ).content_as[dict]
            player_doc = (ctx.get(collection, player_id)).content_as[dict]

            monster_hit_points = monster_doc["hitpoints"]
            monster_new_hitpoints = monster_hit_points - damage

            if monster_new_hitpoints &lt;= 0:
                # Monster is killed. The remove is just for demoing, and a more realistic
                # example would set a "dead" flag or similar.
                ctx.remove(monster_doc)

                # The player earns experience for killing the monster
                experience_for_killing_monster = monster_doc["experience_when_killed"]
                player_experience = player_doc["experience"]
                player_new_experience = player_experience + experience_for_killing_monster
                player_new_level = calculate_level_for_experience(
                    player_new_experience)

                player_content = player_doc.copy()

                player_content["experience"] = player_new_experience
                player_content["level"] = player_new_level

                ctx.replace(player_doc, player_content)
        cluster.transactions.query(txn_logic)
    except TransactionFailed as ex:
        print(f'Transaction did not reach commit point.  Error: {ex}')
        # The operation failed. Both the monster and the player will be untouched.
        #
        # Situations that can cause this would include either the monster
        # or player not existing (as get is used), or a persistent
        # failure to be able to commit the transaction, for example on
        # prolonged node failure.
    except TransactionCommitAmbiguous as ex:
        print(f'Transaction possibly committed.  Error: {ex}')
        # Indicates the state of a transaction ended as ambiguous and may or
        # may not have committed successfully.
        #
        # Situations that may cause this would include a network or node failure
        # after the transactions operations completed and committed, but before the
        # commit result was returned to the client.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Couchbase transactions require a degree of co-operation from an application.
Specifically, the application should ensure that non-transactional writes are never done concurrently with transactional writes, on the same document.</p>
</div>
<div class="paragraph">
<p>This requirement is to ensure that the strong key-value performance of Couchbase was not compromised.
A key philosophy of Couchbase transactions is that you 'pay only for what you use'.</p>
</div>
<div class="paragraph">
<p>If two such writes <strong>do</strong> conflict then the behaviour is undefined: either write may 'win', overwriting the other.
This still applies if the non-transactional write is using CAS.</p>
</div>
<div class="paragraph">
<p>Note this only applies to <em>writes</em>.
Any non-transactional <em>reads</em> concurrent with transactions are fine, and are at a Read Committed level.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rollback"><a class="anchor" href="#rollback"></a>Rollback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If an exception is thrown, either by the application from the lambda, or by the transaction internally, then that attempt is rolled back.
The transaction logic may or may not be retried, depending on the exception.</p>
</div>
<div class="paragraph">
<p>If the transaction is not retried then it will throw an exception, and its <code>message</code> property can be used to inspect the details of the failure.</p>
</div>
<div class="paragraph">
<p>The application can use this to signal why it triggered a rollback, as so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L428-L443">try:
    def txn_logic(ctx):
        customer = ctx.get(collection, "customer-name")

        if customer.content_as[dict]["balance"] &lt; cost_of_item:
            raise InsufficientBalanceException()

        # else continue transaction
    cluster.transactions.run(txn_logic)
except TransactionCommitAmbiguous:
    # This exception can only be thrown at the commit point, after the
    # BalanceInsufficient logic has been passed, so there is no need to
    # check the cause property here.
    pass
except InsufficientBalanceException as e:
    raise InsufficientBalanceException("user had Insufficient balance", e)</code></pre>
</div>
</div>
<div class="paragraph">
<p>After a transaction is rolled back, it cannot be committed, no further operations are allowed on it, and the system will not try to automatically commit it at the end of the code block.</p>
</div>
<div class="paragraph">
<p>There can be situations where total failure is indicated to the application via errors.
These situations include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any error thrown by a transaction lambda, either deliberately or through an application logic bug.</p>
</li>
<li>
<p>Attempting to insert a document that already exists.</p>
</li>
<li>
<p>Calling <code>ctx.get()</code> on a document key that does not exist (if the resultant exception is not caught).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Once one of these errors occurs, the current attempt is irrevocably failed (though the transaction may retry the lambda to make a new attempt).
It is not possible for the application to catch the failure and continue (with the exception of <code>ctx.get()</code> raising an error).
Once a failure has occurred, all other operations tried in this attempt (including commit) will instantly fail.</p>
</div>
<div class="paragraph">
<p>Transactions, as they are multi-stage and multi-document, also have a concept of partial success or failure.
This is signalled to the application through the <code>TransactionResult.unstaging_complete</code> property, described later.</p>
</div>
<div class="paragraph">
<p>There are three exceptions that transactions can raise to an application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>TransactionFailed</code></p>
</li>
<li>
<p><code>TransactionExpired</code></p>
</li>
<li>
<p><code>TransactionCommitAmbiguous</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are some of the exceptions that Couchbase transactions can raise to the application: <code>TransactionFailed</code>, <code>TransactionExpired</code> and <code>TransactionCommitAmbiguous</code>.</p>
</div>
<div class="sect2">
<h3 id="transactionfailed-and-transactionexpired"><a class="anchor" href="#transactionfailed-and-transactionexpired"></a>TransactionFailed and TransactionExpired</h3>
<div class="paragraph">
<p>The transaction definitely did not reach the commit point.
<code>TransactionFailed</code> indicates a fast-failure whereas <code>TransactionExpired</code> indicates that retries were made until the timeout was reached, but this distinction is not normally important to an application and generally <code>TransactionExpired</code> does not need to be handled individually.</p>
</div>
<div class="paragraph">
<p>Either way, an attempt will have been made to rollback all changes.
This attempt may or may not have been successful, but the results of this will have no impact on the protocol or other actors.
No changes from the transaction will be visible, both to transactional and non-transactional actors.</p>
</div>
<div class="sect3">
<h4 id="handling"><a class="anchor" href="#handling"></a>Handling</h4>
<div class="paragraph">
<p>Generally, debugging exactly why a given transaction failed requires review of the logs, so it is suggested that the application log these on failure.
The application may want to try the transaction again later.
Alternatively, if transaction completion time is not a priority, then transaction timeouts (which default to 15 seconds) can be extended across the board through <code>TransactionsConfig</code>.</p>
</div>
<div class="paragraph">
<p>This will allow the protocol more time to get past any transient failures (for example, those caused by a cluster rebalance).
The tradeoff to consider with longer timeouts, is that documents that have been staged by a transaction are effectively locked from modification from other transactions, until the timeout has been reached.</p>
</div>
<div class="paragraph">
<p>Note that the timeout is not guaranteed to be followed precisely.
For example, if the application were to do a long blocking operation inside the lambda (which should be avoided), then timeout can only trigger after this finishes.
Similarly, if the transaction attempts a key-value operation close to the timeout, and that key-value operation times out, then the transaction timeout may be exceeded.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transactioncommitambiguous"><a class="anchor" href="#transactioncommitambiguous"></a>TransactionCommitAmbiguous</h3>
<div class="paragraph">
<p>Each transaction has a 'single point of truth' that is updated atomically to reflect whether it is committed.</p>
</div>
<div class="paragraph">
<p>However, it is not always possible for the protocol to become 100% certain that the operation was successful, before the transaction expires.
This potential ambiguity is unavoidable in any distributed system; a classic example is a network failure happening just after an operation was sent from a client to a server.
The client will not get a response back and cannot know if the server received and executed the operation.</p>
</div>
<div class="paragraph">
<p>The ambiguity is particularly important at the point of the atomic commit, as the transaction may or may not have reached the commit point.  Couchbase transactions will raise <code>TransactionCommitAmbiguous</code> to indicate this state.
It should be rare to receive this error.</p>
</div>
<div class="paragraph">
<p>If the transaction had in fact successfully reached the commit point, then the transaction will be fully completed ("unstaged") by the asynchronous cleanup process at some point in the future.
With default settings this will usually be within a minute, but whatever underlying fault has caused the <code>TransactionCommitAmbiguous</code> may lead to it taking longer.</p>
</div>
<div class="paragraph">
<p>If the transaction had not in fact reached the commit point, then the asynchronous cleanup process will instead attempt to roll it back at some point in the future.</p>
</div>
<div class="sect3">
<h4 id="handling-2"><a class="anchor" href="#handling-2"></a>Handling</h4>
<div class="paragraph">
<p>This error can be challenging for an application to handle.
As with <code>TransactionFailed</code> it is recommended that it at least writes any logs from the transaction, for future debugging.
It may wish to retry the transaction at a later point, or extend transactional timeouts (as detailed above) to give the protocol additional time to resolve the ambiguity.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transactionresult-unstaging_complete"><a class="anchor" href="#transactionresult-unstaging_complete"></a>TransactionResult.unstaging_complete</h3>
<div class="paragraph">
<p>This boolean flag indicates whether all documents were able to be unstaged (committed).</p>
</div>
<div class="paragraph">
<p>For most use-cases it is not an issue if it is false.
All transactional actors will still read all the changes from this transaction, as though it had committed fully.
The cleanup process is asynchronously working to complete the commit, so that it will be fully visible to non-transactional actors.</p>
</div>
<div class="paragraph">
<p>The flag is provided for those rare use-cases where the application requires the commit to be fully visible to non-transactional actors, before it may continue.
In this situation the application can raise an error here, or poll all documents involved until they reflect the mutations.</p>
</div>
<div class="paragraph">
<p>If you regularly see this flag false, consider increasing the transaction timeout to reduce the possibility that the transaction times out during the commit.</p>
</div>
</div>
<div class="sect2">
<h3 id="full-error-handling-example"><a class="anchor" href="#full-error-handling-example"></a>Full Error Handling Example</h3>
<div class="paragraph">
<p>Pulling all of the above together, this is the suggested best practice for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-python//modules/howtos/examples/transactions_example.py#L449-L470">try:
    def txn_logic(ctx):
        # ... transactional code here ...
        pass
    result = cluster.transactions.run(txn_logic)

    # the transaction definitely reached the commit point. Unstaging
    # the individual documents may or may not have completed

    # TODO find python equivalent
    # if(!result.unstaging_complete):
    # In rare cases, the application may require the commit to have
    # completed.  (Recall that the asynchronous cleanup process is
    # still working to complete the commit.)
    # The next step is application-dependent.
except TransactionCommitAmbiguous as ex:
    # The transaction may or may not have reached commit point
    print(
        f'Transaction returned TransactionCommitAmbiguous and may have succeeded.  Error: {ex}')
except TransactionFailed as ex:
    # The transaction definitely did not reach commit point
    print(f'Transaction failed with TransactionFailed.  Error: {ex}')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Transactions will try to clean up after themselves in the advent of failures.
However, there are situations that inevitably created failed, or 'lost' transactions, such as an application crash.</p>
</div>
<div class="paragraph">
<p>This requires an asynchronous cleanup task, described in this section.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="background-cleanup"><a class="anchor" href="#background-cleanup"></a>Background Cleanup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first transaction triggered by an application will spawn a background cleanup task, whose job it is to periodically scan for expired transactions and clean them up.
It does this by scanning a subset of the Active Transaction Record (ATR) transaction metadata documents, for each collection used by any transactions.</p>
</div>
<div class="paragraph">
<p>The default settings are tuned to find expired transactions reasonably quickly, while creating negligible impact from the background reads required by the scanning process.
To be exact, with default settings it will generally find expired transactions within 60 seconds, and use less than 20 reads per second, per collection of metadata documents being checked.
This is unlikely to impact performance on any cluster, but the settings may be <a href="#tuning-cleanup">tuned</a> as desired.</p>
</div>
<div class="paragraph">
<p>All applications connected to the same cluster and running transactions will share in the cleanup, via a low-touch communication protocol on the <code>_txn:client-record</code> metadata document that will be created in each collection in the cluster involved with transaction metadata.
This document is visible and should not be modified externally as it is maintained automatically.
All ATRs will be distributed between all cleanup clients, so increasing the number of applications will not increase the reads required for scanning.</p>
</div>
<div class="paragraph">
<p>An application may cleanup transactions created by another application.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to understand that if an application is not running, then cleanup is not running.
This is particularly relevant to developers running unit tests or similar.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="tuning-cleanup"><a class="anchor" href="#tuning-cleanup"></a>Configuring Cleanup</h3>
<div class="paragraph">
<p>The cleanup settings can be configured as so:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cleanup_window</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60 seconds</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This determines how long a cleanup 'run' is; that is, how frequently this client will check its subset of ATR documents.  It is perfectly valid for the application to change this setting, which is at a conservative default.  Decreasing this will cause expiration transactions to be found more swiftly (generally, within this cleanup window), with the tradeoff of increasing the number of reads per second used for the scanning process.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cleanup_lost_attempts</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the thread that takes part in the distributed cleanup process described above, that cleans up expired transactions created by any client.  It is strongly recommended that it is left enabled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cleanup_client_attempts</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This thread is for cleaning up transactions created just by this client.  The client will preferentially aim to send any transactions it creates to this thread, leaving transactions for the distributed cleanup process only when it is forced to (for example, on an application crash).  It is strongly recommended that it is left enabled.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="monitoring-cleanup"><a class="anchor" href="#monitoring-cleanup"></a>Monitoring Cleanup</h3>
<div class="paragraph">
<p>To monitor cleanup, increase the verbosity on the logging.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logging"><a class="anchor" href="#logging"></a>Logging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To aid troubleshooting, raise the log level on the SDK.</p>
</div>
<div class="paragraph">
<p>Please see the <a href="collecting-information-and-logging.html" class="xref page">Python SDK logging documentation</a> for details.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent-operations"><a class="anchor" href="#concurrent-operations"></a>Concurrent Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The API allows operations to be performed concurrently inside a transaction, which can assist performance.
There are two rules the application needs to follow:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first mutation must be performed alone, in serial.
This is because the first mutation also triggers the creation of metadata for the transaction.</p>
</li>
<li>
<p>All concurrent operations must be allowed to complete fully, so the transaction can track which operations need to be rolled back in the event of failure.
This means the application must 'swallow' the error, but record that an error occurred, and then at the end of the concurrent operations, if an error occurred, throw an error to cause the transaction to retry.</p>
</li>
</ul>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span>© 2022 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script src="../../../_/js/site-navigation-data.js"></script>
<script id="page-navigation-group" type="application/json">
{"title":"SDKs","components":["dotnet-sdk","c-sdk","go-sdk","java-sdk","nodejs-sdk","php-sdk","python-sdk","ruby-sdk","scala-sdk","cxx-txns"],"url":"/home/sdk.html","latestVersions":{"dotnet-sdk":"3.3","c-sdk":"3.3","go-sdk":"2.5","java-sdk":"3.3","nodejs-sdk":"4.1","php-sdk":"4.0","python-sdk":"4.0","ruby-sdk":"3.3","scala-sdk":"1.3","cxx-txns":"DOC-9740"}}
</script>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
