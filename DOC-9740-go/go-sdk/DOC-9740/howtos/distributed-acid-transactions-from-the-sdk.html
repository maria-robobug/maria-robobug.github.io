<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Distributed Transactions from the Go SDK | Couchbase Docs (Local)</title>
<link rel="canonical" href="https://maria-robobug.github.io/DOC-9740-go/go-sdk/DOC-9740/howtos/distributed-acid-transactions-from-the-sdk.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<meta name="description" content="A practical guide to using Couchbaseâ€™s distributed ACID transactions, via the Go API.">
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="go-sdk">
<meta name="dcterms.identifier" content="DOC-9740">
<meta name="page-url" content="/go-sdk/DOC-9740/howtos/distributed-acid-transactions-from-the-sdk.html">
<meta name="generator" content="Antora 3.0.1">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon">
</head>
<body class="article">
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://maria-robobug.github.io/DOC-9740-go/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="https://maria-robobug.github.io/DOC-9740-go/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/sdk.html">
                      SDKs
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
<div class="components">
  <div class="components_group-title">
    <a href="../../../home/sdk.html">SDKs</a>
  </div>
  <ul class="components_list">
    <li class="components_list-items">
      <div class="component_list-version">
        <span class="component_list_title">Go SDK</span>
        <select class="version_list" data-component="go-sdk">
          <option value="DOC-9740" data-url="../hello-world/overview.html" selected>DOC-9740</option>
        </select>
      </div>
      <div class="version_items hide" data-version="DOC-9740">
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Getting Started</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../hello-world/start-using-sdk.html">Start Using the Go SDK</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../hello-world/sample-application.html">Sample Application</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Working with Data</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="kv-operations.html">Key Value Operations</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="subdocument-operations.html">Sub-Document Operations</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="n1ql-queries-with-sdk.html">Query</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="analytics-using-sdk.html">Analytics</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="full-text-searching-with-sdk.html">Search</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="view-queries-with-sdk.html">MapReduce Views</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Advanced Data Operations</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="concurrent-async-apis.html">Async &amp; Batching APIs</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="concurrent-document-mutations.html">Concurrent Document Mutations</a>
  </span>
</li>
<li class="menu_list is-current-page" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link is-current-page" href="distributed-acid-transactions-from-the-sdk.html">Distributed ACID Transactions</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="encrypting-using-sdk.html">Encrypting Your Data</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="transcoders-nonjson.html">Transcoders &amp; Non-JSON</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="working-with-collections.html">Working with Collections</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Managing Couchbase</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="managing-connections.html">Managing Connections</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="sdk-authentication.html">Authentication</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="troubleshooting-cloud-connections.html">Troubleshooting Cloud Connections</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="provisioning-cluster-resources.html">Provisioning Cluster Resources</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="sdk-user-management-example.html">User Management</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Errors &amp; Diagnostics</span>
  </span>
<ul class="menu_row">
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="error-handling.html">Handling Errors</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="slow-operations-logging.html">Slow Operations Logging</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="health-check.html">Health Check</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="collecting-information-and-logging.html">Collecting Information &amp; Logging</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Learn</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/concepts.html">Overview</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/buckets-and-clusters.html">Buckets &amp; Clusters</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/collections.html">Collections &amp; Scope</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/compression.html">Compression</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../concept-docs/data-model.html">Data Model</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/documents.html">Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/nonjson.html">Non-json Docs</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/subdocument-operations.html">Sub-Documents</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/xattr.html">XATTR &amp; Virtual XATTR</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../concept-docs/errors.html">Errors and Diagnostics</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/health-check.html">Health Check</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/response-time-observability.html">Tracing</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/durability-replication-failure-considerations.html">Failure Considerations</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/encryption.html">Field Level Encryption</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../concept-docs/data-services.html">Service Selection</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/analytics-for-sdk-users.html">Analytics</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/understanding-views.html">Map Reduce Views</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/n1ql-query.html">Query</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/full-text-search-overview.html">Search</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../concept-docs/sdk-user-management-overview.html">User Management</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/certificate-based-authentication.html">Cert Auth</a>
  </span>
</li>
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../concept-docs/rbac.html">RBAC</a>
  </span>
</li>
</ul>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Reference</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://pkg.go.dev/github.com/couchbase/gocb/v2">Go API Reference</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../ref/client-settings.html">Client Settings</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../ref/error-codes.html">Error Messages</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../ref/glossary.html">Glossary</a>
  </span>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../ref/travel-app-data-model.html">Travel Sample Data Model</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list is-parent closed" data-depth="0">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <span class="menu_title menu_text">Project Docs</span>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../project-docs/sdk-release-notes.html">Release Notes</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../project-docs/compatibility.html">Compatibility</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../project-docs/migrating-sdk-code-to-3.n.html">Migrating to SDK 3 API</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../project-docs/sdk-licenses.html">Licenses</a>
  </span>
</li>
<li class="menu_list is-parent closed" data-depth="1">
  <span class="menu_line">
    <span class="in-toggle"></span>
    <a class="menu_title menu_link" href="../project-docs/get-involved.html">Get involved</a>
  </span>
<ul class="menu_row">
<li class="menu_list" data-depth="2">
  <span class="menu_line">
    <a class="menu_title menu_link" href="https://docs.couchbase.com/home/contribute/index.html">Improve the Docs</a>
  </span>
</li>
</ul>
</li>
<li class="menu_list" data-depth="1">
  <span class="menu_line">
    <a class="menu_title menu_link" href="../project-docs/metadoc-about-these-sdk-docs.html">About These Docs</a>
  </span>
</li>
</ul>
</li>
</ul>
      </div>
    </li>
  </ul>
</div>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="2">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/howtos/pages/distributed-acid-transactions-from-the-sdk.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../hello-world/overview.html">Go SDK</a></li>
<li class="crumb">Advanced Data Operations</li>
<li class="crumb"><a href="distributed-acid-transactions-from-the-sdk.html">Distributed ACID Transactions</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Distributed Transactions from the Go SDK</h1>
</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
A practical guide to using Couchbaseâ€™s distributed ACID transactions, via the Go API.
</blockquote>
</div>
<div class="paragraph">
<p>This document presents a practical HOWTO on using Couchbase transactions, following on from our <a href="../../../server/7.0/learn/data/transactions.html" class="xref page">transactions documentation</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="requirements"><a class="anchor" href="#requirements"></a>Requirements</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Couchbase Server 7.0.0 or above.</p>
</li>
<li>
<p>Couchbase Go SDK 2.4.0 or above.</p>
</li>
<li>
<p>NTP should be configured so nodes of the Couchbase cluster are in sync with time.</p>
</li>
<li>
<p>The application, if it is using <a href="../concept-docs/xattr.html" class="xref page">extended attributes (XATTRs)</a>, must avoid using the XATTR field <code>txn</code>, which is reserved for Couchbase use.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If using a single node cluster (for example, during development), then note that the default number of replicas for a newly created bucket is 1.
If left at this default, then all Key-Value writes performed at with durability will fail with a <code>ErrDurabilityImpossible</code>.
In turn this will cause all transactions (which perform all Key-Value writes durably) to fail.
This setting can be changed via <a href="../../../server/7.0/manage/manage-buckets/create-bucket.html#couchbase-bucket-settings" class="xref page">GUI</a> or <a href="#7.0@server:cli:cbcli/couchbase-cli-bucket-create.adoc#options" class="xref unresolved">command line</a>.  If the bucket already existed, then the server needs to be rebalanced for the setting to take affect.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase transactions require no additional components or services to be configured.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initializing-transactions"><a class="anchor" href="#initializing-transactions"></a>Initializing Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The starting point is the <code>Transactions</code> object.
The <code>Transactions</code> object is effectively a singleton belonging to a <code>Cluster</code> object, internally <code>Transactions</code> is created on <code>gocb.Connect(..)</code> and its lifetime is bound to the parent <code>Cluster</code> object.
Multiple calls to <code>cluster.Transactions()</code> will yield the same <code>Transactions</code> object, this is because the <code>Transactions</code> object performs automated background processes that should not be duplicated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L17-L35">// Initialize the Couchbase cluster
opts := gocb.ClusterOptions{
	Authenticator: gocb.PasswordAuthenticator{
		Username: "Administrator",
		Password: "password",
	},
}

cluster, err := gocb.Connect("localhost", opts)
if err != nil {
	panic(err)
}

bucket := cluster.Bucket("travel-sample")

scope := bucket.Scope("inventory")
collection := scope.Collection("airport")

transactions := cluster.Transactions()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transactions can optionally be globally configured at the point of creating the <code>Cluster</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L45-L53">opts := gocb.ClusterOptions{
	Authenticator: gocb.PasswordAuthenticator{
		Username: "Administrator",
		Password: "password",
	},
	TransactionsConfig: gocb.TransactionsConfig{
		DurabilityLevel: gocb.DurabilityLevelPersistToMajority,
	},
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration will perform all writes with the durability setting <code>Majority</code>, ensuring that each write is available in-memory on the majority of replicas before the transaction continues.
There are two higher durability settings available that will additionally wait for all mutations to be written to physical storage on either the active or the majority of replicas, before continuing.
This further increases safety, at a cost of additional latency.</p>
</div>
<div class="paragraph">
<p>A level of <code>None</code> is present but its use is discouraged and unsupported.
If durability is set to <code>None</code>, then ACID semantics are not guaranteed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-a-transaction"><a class="anchor" href="#creating-a-transaction"></a>Creating a Transaction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A core idea of Couchbase transactions is that an application supplies the logic for the transaction inside a lambda, including any conditional logic required, and the transaction is then automatically committed.
If a transient error occurs, such as a temporary conflict with another transaction, then the transaction will rollback what has been done so far and run the lambda again.
The application does have to do these retries and error handling itself.</p>
</div>
<div class="paragraph">
<p>Each run of the lambda is called an <code>attempt</code>, inside an overall <code>transaction</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L62-L73">result, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	// The lambda gets passed an AttemptContext object, which permits getting, inserting,
	// removing and replacing documents, and performing N1QL queries.

	// ... Your transaction logic here ...

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	log.Printf("%+v", err)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The lambda gets passed a <code>TransactionAttemptContext</code> object, generally referred to as <code>ctx</code> here.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Since the lambda may be rerun multiple times, it is important that it does not contain any side effects.
In particular, you should never perform regular operations on a <code>Collection</code>, such as <code>collection.Insert()</code>, inside the lambda.
Such operations may be performed multiple times, and will not be performed transactionally.
Instead such operations must be done through the <code>ctx</code> object, e.g. <code>ctx.Insert()</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A code example is worth a thousand words, so here is a quick summary of the main transaction operations.
They are described in more detail below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L83-L179">scope := cluster.Bucket("travel-sample").Scope("inventory")

_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	// Inserting a doc:
	_, err := ctx.Insert(collection, "doc-a", map[string]interface{}{})
	if err != nil {
		return err
	}

	// Getting documents:
	_, err = ctx.Get(collection, "doc-a")
	// Use err != nil &amp;&amp; !errors.Is(err, gocb.ErrDocumentNotFound) if the document may or may not exist
	if err != nil {
		return err
	}

	// Replacing a doc:
	docB, err := ctx.Get(collection, "doc-b")
	if err != nil {
		return err
	}

	var content map[string]interface{}
	err = docB.Content(&amp;content)
	if err != nil {
		return err
	}
	content["transactions"] = "are awesome"
	_, err = ctx.Replace(docB, content)
	if err != nil {
		return err
	}

	// Removing a doc:
	docC, err := ctx.Get(collection, "doc-c")
	if err != nil {
		return err
	}

	err = ctx.Remove(docC)
	if err != nil {
		return err
	}

	// Performing a SELECT N1QL query against a scope:
	qr, err := ctx.Query("SELECT * FROM hotel WHERE country = $1", &amp;gocb.TransactionQueryOptions{
		PositionalParameters: []interface{}{"United Kingdom"},
		Scope:                scope,
	})
	if err != nil {
		return err
	}

	type hotel struct {
		Name string `json:"name"`
	}

	var hotels []hotel
	for qr.Next() {
		var h hotel
		err = qr.Row(&amp;h)
		if err != nil {
			return err
		}

		hotels = append(hotels, h)
	}

	// Performing an UPDATE N1QL query on multiple documents, in the `inventory` scope:
	_, err = ctx.Query("UPDATE route SET airlineid = $1 WHERE airline = $2", &amp;gocb.TransactionQueryOptions{
		PositionalParameters: []interface{}{"airline_137", "AF"},
		Scope:                scope,
	})
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
var ambigErr gocb.TransactionCommitAmbiguousError
if errors.As(err, &amp;ambigErr) {
	log.Println("Transaction possibly committed")

	log.Printf("%+v", ambigErr)
	return
}
var failedErr gocb.TransactionFailedError
if errors.As(err, &amp;failedErr) {
	log.Println("Transaction did not reach commit point")

	log.Printf("%+v", failedErr)
	return
}
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mechanics"><a class="anchor" href="#mechanics"></a>Transaction Mechanics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While this document is focussed on presenting how transactions are used at the API level, it is useful to have a high-level understanding of the mechanics.
Reading this section is completely optional.</p>
</div>
<div class="paragraph">
<p>Recall that the application-provided lambda (containing the transaction logic) may be run multiple times by Couchbase transactions.
Each such run is called an <code>attempt</code> inside the overall transaction.</p>
</div>
<div class="sect2">
<h3 id="active-transaction-record-entries"><a class="anchor" href="#active-transaction-record-entries"></a>Active Transaction Record Entries</h3>
<div class="paragraph">
<p>The first mechanic is that each of these attempts adds an entry to a metadata document in the Couchbase cluster.
These metadata documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Are named Active Transaction Records, or ATRs.</p>
</li>
<li>
<p>Are created and maintained automatically.</p>
</li>
<li>
<p>Begin with "_txn:atr-".</p>
</li>
<li>
<p>Each contain entries for multiple attempts.</p>
</li>
<li>
<p>Are viewable, and <em>they should not be modified externally</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each such ATR entry stores some metadata and, crucially, whether the attempt has committed or not.
In this way, the entry acts as the single point of truth for the transaction, which is essential for providing an 'atomic commit' during reads.</p>
</div>
</div>
<div class="sect2">
<h3 id="staged-mutations"><a class="anchor" href="#staged-mutations"></a>Staged Mutations</h3>
<div class="paragraph">
<p>The second mechanic is that mutating a document inside a transaction, does not directly change the body of the document.
Instead, the post-transaction version of the document is staged alongside the document (technically in its <a href="../concept-docs/xattr.html" class="xref page">extended attributes (XATTRs)</a>).
In this way, all changes are invisible to all parts of the Couchbase Data Platform until the commit point is reached.</p>
</div>
<div class="paragraph">
<p>These staged document changes effectively act as a lock against other transactions trying to modify the document, preventing write-write conflicts.</p>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>Cleanup</h3>
<div class="paragraph">
<p>There are safety mechanisms to ensure that leftover staged changes from a failed transaction cannot block live transactions indefinitely.
These include an asynchronous cleanup process that is started with the first transaction, and scans for expired transactions created by any application, on the relevant collections.</p>
</div>
<div class="paragraph">
<p>Note that if an application is not running, then this cleanup is also not running.</p>
</div>
<div class="paragraph">
<p>The cleanup process is detailed below in <a href="#asynchronous-cleanup">Asynchronous Cleanup</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="committing"><a class="anchor" href="#committing"></a>Committing</h3>
<div class="paragraph">
<p>Only once the lambda has successfully run to conclusion, will the attempt be committed.
This updates the ATR entry, which is used as a signal by transactional actors to use the post-transaction version of a document from its XATTRs.
Hence, updating the ATR entry is an 'atomic commit' switch for the transaction.</p>
</div>
<div class="paragraph">
<p>After this commit point is reached, the individual documents will be committed (or "unstaged").
This provides an eventually consistent commit for non-transactional actors.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="key-value-mutations"><a class="anchor" href="#key-value-mutations"></a>Key-Value Mutations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="replacing"><a class="anchor" href="#replacing"></a>Replacing</h3>
<div class="paragraph">
<p>Replacing a document requires a <code>ctx.Get()</code> call first.
This is necessary so that the transaction can check that the document is not involved in another transaction.
If it is, then the SDK will handle this at the <code>ctx.Replace()</code> point.
Generally, this involves rolling back what has been done so far, and retrying the lambda.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L286-L309">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	doc, err := ctx.Get(collection, "replace-doc")
	if err != nil {
		return err
	}

	var content map[string]interface{}
	err = doc.Content(&amp;content)
	if err != nil {
		return err
	}
	content["transactions"] = "are awesome"

	_, err = ctx.Replace(doc, content)
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="removing"><a class="anchor" href="#removing"></a>Removing</h3>
<div class="paragraph">
<p>As with replaces, removing a document requires a <code>ctx.Get()</code> call first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L321-L337">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	doc, err := ctx.Get(collection, "remove-doc")
	if err != nil {
		return err
	}

	err = ctx.Remove(doc)
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inserting"><a class="anchor" href="#inserting"></a>Inserting</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L187-L198">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	_, err := ctx.Insert(collection, "insert-doc", map[string]interface{}{})
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="key-value-reads"><a class="anchor" href="#key-value-reads"></a>Key-Value Reads</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L210-L227">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	doc, err := ctx.Get(collection, "get-doc")
	if err != nil {
		return err
	}

	var content interface{}
	err = doc.Content(&amp;content)
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Getting a document with Key-Value can return an <code>ErrDocumentNotFound</code> which can be ignored if you are unsure if the document exists, or it not existing does not matter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L231-L244">_, err = cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	doc, err := ctx.Get(collection, "get-doc")
	if err != nil &amp;&amp; !errors.Is(err, gocb.ErrDocumentNotFound) {
		return err
	}

	fmt.Println(doc != nil)

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>ErrDocumentNotFound</code> is not ignored then <code>Get</code> will cause the transaction to fail with <code>TransactionFailedError</code> (after rolling back any changes, of course).
<code>ErrDocumentNotFound</code> is one of very few errors that the SDK will allow you to ignore, the SDK internally tracks the state of the transaction and will not allow illegal operations to continue.</p>
</div>
<div class="paragraph">
<p>Gets will 'read your own writes', e.g. this will succeed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L252-L274">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	_, err := ctx.Insert(collection, "ownwritesdoc", map[string]interface{}{})
	if err != nil {
		return err
	}

	doc, err := ctx.Get(collection, "ownwritesdoc")
	if err != nil {
		return err
	}

	var content interface{}
	err = doc.Content(&amp;content)
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="n1ql-queries"><a class="anchor" href="#n1ql-queries"></a>N1QL Queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As of Couchbase Server 7.0, N1QL queries may be used inside the transaction lambda, freely mixed with Key-Value operations.</p>
</div>
<div class="sect2">
<h3 id="begin-transaction"><a class="anchor" href="#begin-transaction"></a>BEGIN TRANSACTION</h3>
<div class="paragraph">
<p>There are two ways to initiate a transaction with Couchbase 7.0: via the SDK, and via the query service directly using <code>BEGIN TRANSACTION</code>.
The latter is intended for those using query via the REST API, or using the query workbench in the UI, and it is strongly recommended that application writers instead use the SDK.
This provides these benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It automatically handles errors and retrying.</p>
</li>
<li>
<p>It allows Key-Value operations and N1QL queries to be freely mixed.</p>
</li>
<li>
<p>It takes care of issuing <code>BEGIN TRANSACTION</code>, <code>END TRANSACTION</code>, <code>COMMIT</code> and <code>ROLLBACK</code> automatically.  These become an implementation detail and you should not use these statements inside the lambda.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="supported-n1ql"><a class="anchor" href="#supported-n1ql"></a>Supported N1QL</h3>
<div class="paragraph">
<p>The majority of N1QL DML statements are permitted within a transaction.  Specifically: INSERT, UPSERT, DELETE, UPDATE, MERGE and SELECT are supported.</p>
</div>
<div class="paragraph">
<p>DDL statements, such as CREATE INDEX, are not.</p>
</div>
</div>
<div class="sect2">
<h3 id="using-n1ql"><a class="anchor" href="#using-n1ql"></a>Using N1QL</h3>
<div class="paragraph">
<p>If you already use N1QL from the Go SDK, then its use in transactions is very similar.
It returns a similar <code>TransactionsQueryResult</code>, and takes most of the same options.
The main difference between <code>TransactionsQueryResult</code> and <code>QueryResult</code> is that <code>TransactionsQueryResult</code> does not stream results.
This means that there are no <code>Err</code> or <code>Close</code> functions and that result sets are buffered in memory - allowing the SDK to read and handle any errors that occur on the stream before returning a result/error.</p>
</div>
<div class="paragraph">
<p>You must take care to write <code>ctx.Query()</code> inside the lambda however, rather than <code>cluster.Query()</code> or <code>scope.Query()</code>.</p>
</div>
<div class="paragraph">
<p>An example of selecting some rows from the <code>travel-sample</code> bucket:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L345-L373">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	qr, err := ctx.Query("SELECT * FROM `travel-sample`.inventory.hotel WHERE country = $1", &amp;gocb.TransactionQueryOptions{
		PositionalParameters: []interface{}{"United Kingdom"},
	})
	if err != nil {
		return err
	}

	type hotel struct {
		Name string `json:"name"`
	}

	var hotels []hotel
	for qr.Next() {
		var h hotel
		err = qr.Row(&amp;h)
		if err != nil {
			return err
		}

		hotels = append(hotels, h)
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rather than specifying the full "`travel-sample`.inventory.hotel" name each time, it is easier to pass a reference to the inventory <code>Scope</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L381-L412">bucket := cluster.Bucket("travel-sample")
scope := bucket.Scope("inventory")
_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	qr, err := ctx.Query("SELECT * FROM hotel WHERE country = $1", &amp;gocb.TransactionQueryOptions{
		PositionalParameters: []interface{}{"United Kingdom"},
		Scope:                scope,
	})
	if err != nil {
		return err
	}

	type hotel struct {
		Name string `json:"name"`
	}

	var hotels []hotel
	for qr.Next() {
		var h hotel
		err = qr.Row(&amp;h)
		if err != nil {
			return err
		}

		hotels = append(hotels, h)
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example using a <code>Scope</code> for an UPDATE operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L420-L445">bucket := cluster.Bucket("travel-sample")
scope := bucket.Scope("inventory")
_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	qr, err := ctx.Query("UPDATE hotel SET price = $1 WHERE url LIKE $2 AND country = $3", &amp;gocb.TransactionQueryOptions{
		PositionalParameters: []interface{}{99.99, "http://marriot%", "United Kingdom"},
		Scope:                scope,
	})
	if err != nil {
		return err
	}

	meta, err := qr.MetaData()
	if err != nil {
		return err
	}

	if meta.Metrics.MutationCount != 1 {
		panic("Should have received 1 mutation")
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And an example combining SELECTs and UPDATEs.
It&#8217;s possible to call regular Go functions from the lambda, as shown here, permitting complex logic to be performed.
Just remember that since the lambda may be called multiple times, so may the method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L453-L482">bucket := cluster.Bucket("travel-sample")
scope := bucket.Scope("inventory")
_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	// Find all hotels of the chain
	qr, err := ctx.Query("SELECT reviews FROM hotel WHERE url LIKE $1 AND country = $2", &amp;gocb.TransactionQueryOptions{
		PositionalParameters: []interface{}{"http://marriot%", "United Kingdom"},
		Scope:                scope,
	})
	if err != nil {
		return err
	}

	// This function (not provided here) will use a trained machine learning model to provide a
	// suitable price based on recent customer reviews
	updatedPrice := priceFromRecentReviews(qr)

	_, err = ctx.Query("UPDATE hotel SET price = $1 WHERE url LIKE $2 AND country = $3", &amp;gocb.TransactionQueryOptions{
		PositionalParameters: []interface{}{updatedPrice, "http://marriot%", "United Kingdom"},
		Scope:                scope,
	})
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="read-your-own-writes"><a class="anchor" href="#read-your-own-writes"></a>Read Your Own Writes</h3>
<div class="paragraph">
<p>As with Key-Value operations, N1QL queries support Read Your Own Writes.</p>
</div>
<div class="paragraph">
<p>This example shows inserting a document and then selecting it again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L490-L516">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	_, err := ctx.Query("INSERT INTO `default` VALUES ('doc', {'hello':'world'})", nil) <i class="conum" data-value="1"></i><b>(1)</b>
	if err != nil {
		return err
	}

	st := "SELECT `default`.* FROM `default` WHERE META().id = 'doc'" <i class="conum" data-value="2"></i><b>(2)</b>
	qr, err := ctx.Query(st, nil)
	if err != nil {
		return err
	}

	meta, err := qr.MetaData()
	if err != nil {
		return err
	}

	if meta.Metrics.ResultCount != 1 {
		panic("Should have received 1 result")
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The inserted document is only staged at this point, as the transaction has not yet committed.
Other transactions, and other non-transactional actors, will not be able to see this staged insert yet.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>But the SELECT can, as we are reading a mutation staged inside the same transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mixing-key-value-and-n1ql"><a class="anchor" href="#mixing-key-value-and-n1ql"></a>Mixing Key-Value and N1QL</h3>
<div class="paragraph">
<p>Key-Value operations and queries can be freely intermixed, and will interact with each other as you would expect.</p>
</div>
<div class="paragraph">
<p>In this example we insert a document with Key-Value, and read it with a SELECT.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L524-L550">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	_, err := ctx.Insert(collection, "queryRyow", map[string]interface{}{"hello": "world"}) <i class="conum" data-value="1"></i><b>(1)</b>
	if err != nil {
		return err
	}

	st := "SELECT `default`.* FROM `default` WHERE META().id = 'queryRyow'" <i class="conum" data-value="2"></i><b>(2)</b>
	qr, err := ctx.Query(st, nil)
	if err != nil {
		return err
	}

	meta, err := qr.MetaData()
	if err != nil {
		return err
	}

	if meta.Metrics.ResultCount != 1 {
		panic("Should have received 1 result")
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>As with the 'Read Your Own Writes' example, here the insert is only staged, and so it is not visible to other transactions or non-transactional actors.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>But the SELECT can view it, as the insert was in the same transaction.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="query-options"><a class="anchor" href="#query-options"></a>Query Options</h3>
<div class="paragraph">
<p>Query options can be provided via <code>TransactionQueryOptions</code>, which provides a subset of the options in the Go SDK&#8217;s <code>QueryOptions</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L558-L571">_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	_, err := ctx.Query("INSERT INTO `default` VALUES ('queryOpts', {'hello':'world'})", &amp;gocb.TransactionQueryOptions{
		Profile: gocb.QueryProfileModeTimings,
	})
	if err != nil {
		return err
	}

	// There is no commit call, by not returning an error the transaction will automatically commit
	return nil
}, nil)
if err != nil {
	panic(err)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The supported options are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PositionalParameters</p>
</li>
<li>
<p>NamedParameters</p>
</li>
<li>
<p>ScanConsistency</p>
</li>
<li>
<p>FlexIndex</p>
</li>
<li>
<p>ClientContextID</p>
</li>
<li>
<p>ScanWait</p>
</li>
<li>
<p>ScanCap</p>
</li>
<li>
<p>PipelineBatch</p>
</li>
<li>
<p>PipelineCap</p>
</li>
<li>
<p>Profile</p>
</li>
<li>
<p>Readonly</p>
</li>
<li>
<p>Raw</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="n1ql-queries-with-sdk.html#query-options" class="xref page">QueryOptions documentation</a> for details on these.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-concurrency"><a class="anchor" href="#query-concurrency"></a>Query Concurrency</h3>
<div class="paragraph">
<p>Only one query statement will be performed by the query service at a time.
Non-blocking mechanisms can be used to perform multiple concurrent query statements, but this may result internally in some added network traffic due to retries, and is unlikely to provide any increased performance.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-performance-advice"><a class="anchor" href="#query-performance-advice"></a>Query Performance Advice</h3>
<div class="paragraph">
<p>This section is optional reading, and only for those looking to maximize transactions performance.</p>
</div>
<div class="paragraph">
<p>After the first query statement in a transaction, subsequent Key-Value operations in the lambda are converted into N1QL and executed by the query service rather than the Key-Value data service.
The operation will behave identically, and this implementation detail can largely be ignored, except for these two caveats:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>These converted Key-Value operations are likely to be slightly slower, as the query service is optimized for statements involving multiple documents.
Those looking for the maximum possible performance are recommended to put Key-Value operations before the first query in the lambda, if possible.</p>
</li>
<li>
<p>Those using non-blocking mechanisms to achieve concurrency should be aware that the converted Key-Value operations are subject to the same parallelism restrictions mentioned above, e.g. they will not be executed in parallel by the query service.
If possible, concurrent Key-Value operations should be moved before the first query.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="committing-2"><a class="anchor" href="#committing-2"></a>Committing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Committing is automatic: if no errors are returned, the transaction will be committed.</p>
</div>
<div class="paragraph">
<p>As soon as the transaction is committed, all its changes will be atomically visible to reads from other transactions.
The changes will also be committed (or "unstaged") so they are visible to non-transactional actors, in an eventually consistent fashion.</p>
</div>
<div class="paragraph">
<p>Commit is final: after the transaction is committed, it cannot be rolled back, and no further operations are allowed on it.</p>
</div>
<div class="paragraph">
<p>An asynchronous cleanup process ensures that once the transaction reaches the commit point, it will be fully committed - even if the application crashes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-full-transaction-example"><a class="anchor" href="#a-full-transaction-example"></a>A Full Transaction Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s pull together everything so far into a more real-world example of a transaction.</p>
</div>
<div class="paragraph">
<p>This example simulates a simple Massively Multiplayer Online game, and includes documents representing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Players, with experience points and levels;</p>
</li>
<li>
<p>Monsters, with hitpoints, and the number of experience points a player earns from their death.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this example, the player is dealing damage to the monster.
The playerâ€™s client has sent this instruction to a central server, where weâ€™re going to record that action.
Weâ€™re going to do this in a transaction, as we donâ€™t want a situation where the monster is killed, but we fail to update the playerâ€™s document with the earned experience.</p>
</div>
<div class="paragraph">
<p>(Though this is just a demo - in reality, the game would likely live with the small risk and limited impact of this, rather than pay the performance cost for using a transaction.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L581-L662">func playerHitsMonster(damage int, playerID, monsterID string) {
	type monster struct {
		Hitpoints            int `json:"hitpoints"`
		ExperienceWhenKilled int `json:"experience_when_killed"`
	}

	type player struct {
		Experience int `json:"experience"`
		Level      int `json:"level"`
	}

	initTransactions(func(cluster *gocb.Cluster, collection *gocb.Collection) {
		_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
			monsterDoc, err := ctx.Get(collection, monsterID)
			if err != nil {
				return err
			}
			playerDoc, err := ctx.Get(collection, monsterID)
			if err != nil {
				return err
			}

			var monsterContent monster
			if err := monsterDoc.Content(&amp;monsterContent); err != nil {
				return err
			}

			monsterNewHitPoints := monsterContent.Hitpoints - damage

			if monsterNewHitPoints &lt;= 0 {
				// Monster is killed. The remove is just for demoing, and a more realistic
				// example would set a "dead" flag or similar.
				err = ctx.Remove(monsterDoc)
				if err != nil {
					return err
				}

				var playerContent player
				if err := playerDoc.Content(&amp;playerContent); err != nil {
					return err
				}

				// The player earns experience for killing the monster
				playerNewExperience := playerContent.Experience + monsterContent.ExperienceWhenKilled
				playerNewLevel := calculateLevelForExperience(playerNewExperience)

				playerContent.Experience = playerNewExperience
				playerContent.Level = playerNewLevel

				_, err = ctx.Replace(playerDoc, playerContent)
				if err != nil {
					return err
				}
			} else {
				// Monster is damaged but still alive
				monsterContent.Hitpoints = monsterNewHitPoints

				_, err = ctx.Replace(monsterDoc, monsterContent)
				if err != nil {
					return err
				}
			}

			return nil
		}, nil)
		var transactionFailedErr gocb.TransactionFailedError
		if errors.As(err, &amp;transactionFailedErr) {
			// The operation failed. Both the monster and the player will be untouched.

			// Situations that can cause this would include either the monster
			// or player not existing (as get is used), or a persistent
			// failure to be able to commit the transaction, for example on
			// prolonged node failure.
			return
		}

		if err != nil {
			panic(err)
		}
	})
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrency-with-non-transactional-writes"><a class="anchor" href="#concurrency-with-non-transactional-writes"></a>Concurrency with Non-Transactional Writes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This release of transactions for Couchbase requires a degree of co-operation from the application.
Specifically, the application should ensure that non-transactional writes are never done concurrently with transactional writes, on the same document.</p>
</div>
<div class="paragraph">
<p>This requirement is to ensure that the strong Key-Value performance of Couchbase was not compromised.
A key philosophy of our transactions is that you 'pay only for what you use'.</p>
</div>
<div class="paragraph">
<p>If two such writes <strong>do</strong> conflict then the transactional write will 'win', overwriting the non-transactional write.</p>
</div>
<div class="paragraph">
<p>Note this only applies to <em>writes</em>.
Any non-transactional <em>reads</em> concurrent with transactions are fine, and are at a Read Committed level.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rollback"><a class="anchor" href="#rollback"></a>Rollback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If an exception is thrown, either by the application from the lambda, or by the transaction internally, then that attempt is rolled back.
The transaction logic may or may not be retried, depending on the exception.</p>
</div>
<div class="paragraph">
<p>If the transaction is not retried then it will return a <code>TransactionFailedError</code> error, and its <code>Unwrap</code> function can be used for more details on the failure.</p>
</div>
<div class="paragraph">
<p>The application can use this to signal why it triggered a rollback, as so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L673-L714">var ErrBalanceInsufficient = errors.New("insufficient funds")

_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	doc, err := ctx.Get(collection, "customer-name")
	if err != nil {
		return err
	}

	var cust customer
	err = doc.Content(&amp;cust)
	if err != nil {
		return err
	}

	if cust.Balance &lt; costOfItem {
		return ErrBalanceInsufficient
	}
	// else continue transaction

	return nil
}, nil)
var ambigErr gocb.TransactionCommitAmbiguousError
if errors.As(err, &amp;ambigErr) {
	// This exception can only be thrown at the commit point, after the
	// BalanceInsufficient logic has been passed, so there is no need to
	// check getCause here.
	fmt.Println("Transaction possibly committed")
	fmt.Printf("%+v", ambigErr)
	return
}

var transactionFailedErr gocb.TransactionFailedError
if errors.As(err, &amp;transactionFailedErr) {
	if errors.Is(transactionFailedErr, ErrBalanceInsufficient) {
		// Re-raise the error
		panic(transactionFailedErr)
	} else {
		fmt.Println("Transaction did not reach commit point")
		fmt.Printf("%+v", transactionFailedErr)
	}
	return
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After a transaction is rolled back, it cannot be committed, no further operations are allowed on it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="error-handling"><a class="anchor" href="#error-handling"></a>Error Handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As discussed previously, Couchbase transactions will attempt to resolve many errors for you, through a combination of retrying individual operations and the application&#8217;s lambda.
This includes some transient server errors, and conflicts with other transactions.</p>
</div>
<div class="paragraph">
<p>But there are situations that cannot be resolved, and total failure is indicated to the application via errors.
These errors include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any error thrown by your transaction lambda, either deliberately or through an application logic bug.</p>
</li>
<li>
<p>Attempting to insert a document that already exists.</p>
</li>
<li>
<p>Attempting to remove or replace a document that does not exist.</p>
</li>
<li>
<p>Calling <code>ctx.Get()</code> on a document key that does not exist.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Once one of these errors occurs, the current attempt is irrevocably failed (though the transaction may retry the lambda).
It is not possible for the application to catch the failure and continue.
Once a failure has occurred, all other operations tried in this attempt (including commit) will instantly fail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Transactions, as they are multi-stage and multi-document, also have a concept of partial success or failure.
This is signalled to the application through the <code>TransactionResult.UnstagingComplete</code> field, described later.</p>
</div>
<div class="paragraph">
<p>There are three errors that Couchbase transactions can return to the application: <code>TransactionFailedError</code>, <code>TransactionExpiredError</code> and <code>TransactionCommitAmbiguousError</code>.</p>
</div>
<div class="sect2">
<h3 id="transactionfailederror-and-transactionexpirederror"><a class="anchor" href="#transactionfailederror-and-transactionexpirederror"></a>TransactionFailedError and TransactionExpiredError</h3>
<div class="paragraph">
<p>The transaction definitely did not reach the commit point.
<code>TransactionFailedError</code> indicates a fast-failure whereas <code>TransactionExpiredError</code> indicates that retries were made until the expiration point was reached, but this distinction is not normally important to the application and generally <code>TransactionExpiredError</code> does not need to be handled individually.</p>
</div>
<div class="paragraph">
<p>Either way, an attempt will have been made to rollback all changes.
This attempt may or may not have been successful, but the results of this will have no impact on the protocol or other actors.
No changes from the transaction will be visible (presently with the potential and temporary exception of staged inserts being visible to non-transactional actors, as discussed under <a href="#inserting">Inserting</a>).</p>
</div>
<div class="paragraph">
<p><strong>Handling:</strong> Generally, debugging exactly why a given transaction failed requires review of the logs, so it is suggested that the application log these on failure (see <a href="#logging">Logging</a>).
The application may want to try the transaction again later.
Alternatively, if transaction completion time is not a priority, then transaction expiration times (which default to 15 seconds) can be extended across the board through <code>TransactionsConfig</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L721-L725">cluster, err := gocb.Connect("localhost", gocb.ClusterOptions{
	TransactionsConfig: gocb.TransactionsConfig{
		Timeout: 120 * time.Second,
	},
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will allow the protocol more time to get past any transient failures (for example, those caused by a cluster rebalance).
The tradeoff to consider with longer expiration times, is that documents that have been staged by a transaction are effectively locked from modification from other transactions, until the expiration time has exceeded.</p>
</div>
<div class="paragraph">
<p>Note that expiration is not guaranteed to be followed precisely.
For example, if the application were to do a long blocking operation inside the lambda (which should be avoided), then expiration can only trigger after this finishes.
Similarly, if the transaction attempts a key-value operation close to the expiration time, and that key-value operation times out, then the expiration time may be exceeded.</p>
</div>
</div>
<div class="sect2">
<h3 id="transactioncommitambiguouserror"><a class="anchor" href="#transactioncommitambiguouserror"></a>TransactionCommitAmbiguousError</h3>
<div class="paragraph">
<p>As discussed <a href="#mechanics">previously</a>, each transaction has a 'single point of truth' that is updated atomically to reflect whether it is committed.</p>
</div>
<div class="paragraph">
<p>However, it is not always possible for the protocol to become 100% certain that the operation was successful, before the transaction expires.
That is, the operation may have successfully completed on the cluster, or may succeed soon, but the protocol is unable to determine this (whether due to transient network failure or other reason).
This is important as the transaction may or may not have reached the commit point, e.g. succeeded or failed.</p>
</div>
<div class="paragraph">
<p>Couchbase transactions will raise <code>TransactionCommitAmbiguousError</code> to indicate this state.
It should be rare to receive this error.</p>
</div>
<div class="paragraph">
<p>If the transaction had in fact successfully reached the commit point, then the transaction will be fully completed ("unstaged") by the asynchronous cleanup process at some point in the future.
With default settings this will usually be within a minute, but whatever underlying fault has caused the <code>TransactionCommitAmbiguousError</code> may lead to it taking longer.</p>
</div>
<div class="paragraph">
<p>If the transaction had not in fact reached the commit point, then the asynchronous cleanup process will instead attempt to roll it back at some point in the future.
If unable to, any staged metadata from the transaction will not be visible, and will not cause problems (e.g. there are safety mechanisms to ensure it will not block writes to these documents for long).</p>
</div>
<div class="paragraph">
<p><strong>Handling:</strong> This error can be challenging for an application to handle.
As with <code>TransactionFailedError</code> it is recommended that it at least writes any logs from the transaction, for future debugging.
It may wish to retry the transaction at a later point, or globally extend transactional expiration times to give the protocol additional time to resolve the ambiguity.</p>
</div>
</div>
<div class="sect2">
<h3 id="transactionresult-unstagingcomplete"><a class="anchor" href="#transactionresult-unstagingcomplete"></a>TransactionResult.UnstagingComplete</h3>
<div class="paragraph">
<p>This boolean flag indicates whether all documents were able to be unstaged (committed).</p>
</div>
<div class="paragraph">
<p>For most use-cases it is not an issue if it is false.
All transactional actors will still all the changes from this transaction, as though it had committed fully.
The cleanup process is asynchronously working to complete the commit, so that it will be fully visible to non-transactional actors.</p>
</div>
<div class="paragraph">
<p>The flag is provided for those rare use-cases where the application requires the commit to be fully visible to non-transactional actors, before it may continue.
In this situation the application can raise an error here, or poll all documents involved until they reflect the mutations.</p>
</div>
<div class="paragraph">
<p>If you regularly see this flag false, consider increasing the transaction expiration time to reduce the possibility that the transaction times out during the commit.</p>
</div>
</div>
<div class="sect2">
<h3 id="full-error-handling-example"><a class="anchor" href="#full-error-handling-example"></a>Full Error Handling Example</h3>
<div class="paragraph">
<p>Pulling all of the above together, this is the suggested best practice for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L766-L797">result, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	// ... transactional code here ...
	return nil
}, nil)
var ambigErr gocb.TransactionCommitAmbiguousError
if errors.As(err, &amp;ambigErr) {
	fmt.Println("Transaction returned TransactionCommitAmbiguous and may have succeeded")

	// Of course, the application will want to use its own logging rather
	// than fmt.Printf
	fmt.Printf("%+v", ambigErr)
	return
}
var transactionFailedErr gocb.TransactionFailedError
if errors.As(err, &amp;transactionFailedErr) {
	// The transaction definitely did not reach commit point
	fmt.Println("Transaction failed with TransactionFailed")
	fmt.Printf("%+v", transactionFailedErr)
	return
}
if err != nil {
	panic(err)
}

// The transaction definitely reached the commit point. Unstaging
// the individual documents may or may not have completed
if !result.UnstagingComplete {
	// In rare cases, the application may require the commit to have
	// completed.  (Recall that the asynchronous cleanup process is
	// still working to complete the commit.)
	// The next step is application-dependent.
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="asynchronous-cleanup"><a class="anchor" href="#asynchronous-cleanup"></a>Asynchronous Cleanup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transactions will try to clean up after themselves in the advent of failures.
However, there are situations that inevitably created failed, or 'lost' transactions, such as an application crash.</p>
</div>
<div class="paragraph">
<p>This requires an asynchronous cleanup task, described in this section.</p>
</div>
<div class="paragraph">
<p>Calling <code>Connect</code> spawns a background cleanup task, whose job it is to periodically scan for expired transactions and clean them up.
It does this by scanning a subset of the Active Transaction Record (ATR) transaction metadata documents, for each metadata collection used by any transactions.
As you&#8217;ll recall from <a href="#mechanics">earlier</a>, an entry for each transaction attempt exists in one of these documents.
They are removed during cleanup or at some time after successful completion.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unless there are any metadata collections registered (either from config or by running a transaction) then the background cleanup task will do no work and so is very lightweight.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default settings are tuned to find expired transactions reasonably quickly, while creating negligible impact from the background reads required by the scanning process.
To be exact, with default settings it will generally find expired transactions within 60 seconds, and use less than 20 reads per second.
This is unlikely to impact performance on any cluster, but the settings may be <a href="#tuning-cleanup">tuned</a> as desired.</p>
</div>
<div class="paragraph">
<p>All applications connected to the same cluster and running <code>Transactions</code> will share in the cleanup, via a low-touch communication protocol on the "_txn:client-record" metadata document that will be created in each metadata collection used during transactions.
This document is visible and should not be modified externally as is maintained automatically.
All ATRs on a metadata collection will be distributed between all cleanup clients, so increasing the number of applications will not increase the reads required for scanning.</p>
</div>
<div class="paragraph">
<p>An application may cleanup transactions created by another application.</p>
</div>
<div class="paragraph">
<p>It is important to understand that if an application is not running, then cleanup is not running.
This is particularly relevant to developers running unit tests or similar.</p>
</div>
<div class="paragraph">
<p>If this is an issue, then the deployment may want to consider running a simple application at all times that just call <code>Connect</code>, to guarantee that cleanup is running.
When an application is used solely for cleanup it <strong>must</strong> register any collections to monitor via the <code>CleanupCollections</code> config option, otherwise the cleanup task will not do any work.
Only the collections registered will be monitored.</p>
</div>
<div class="sect2">
<h3 id="tuning-cleanup"><a class="anchor" href="#tuning-cleanup"></a>Configuring Cleanup</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CleanupWindow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60 seconds</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This determines how long a cleanup 'run' is; that is, how frequently this client will check its subset of ATR documents. It is perfectly valid for the application to change this setting, which is at a conservative default. Decreasing this will cause expiration transactions to be found more swiftly (generally, within this cleanup window), with the tradeoff of increasing the number of reads per second used for the scanning process.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisableLostAttemptCleanup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the thread that takes part in the distributed cleanup process described above, that cleans up expired transactions created by any client. It is strongly recommended that it is left enabled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisableClientAttemptCleanup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This thread is for cleaning up transactions created just by this client. The client will preferentially aim to send any transactions it creates to this thread, leaving transactions for the distributed cleanup process only when it is forced to (for example, on an application crash). It is strongly recommended that it is left enabled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CleanupCollections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[]TransactionKeyspace{}</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the set of additional collections that the lost transactions cleanup task will monitor</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="monitoring-cleanup"><a class="anchor" href="#monitoring-cleanup"></a>Monitoring Cleanup</h3>
<div class="paragraph">
<p>To monitor cleanup, increase the verbosity on the logging.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logging"><a class="anchor" href="#logging"></a>Logging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To aid troubleshooting, raise the log level on the SDK.</p>
</div>
<div class="paragraph">
<p>Please see the <a href="collecting-information-and-logging.html" class="xref page">Go SDK logging documentation</a> for details.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="custom-metadata-collections"><a class="anchor" href="#custom-metadata-collections"></a>Custom Metadata Collections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As described earlier, transactions automatically create and use metadata documents.
By default, these are created in the default collection of the bucket of the first mutated document in the transaction.
Optionally, you can instead use a collection to store the metadata documents.
Most users will not need to use this functionality, and can continue to use the default behavior.
They are provided for these use-cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The metadata documents contain, for documents involved in each transaction, the document&#8217;s key and the name of the bucket, scope and collection it exists on.
In some deployments this may be sensitive data.</p>
</li>
<li>
<p>You wish to remove the default collections.
Before doing this, you should ensure that all existing transactions using metadata documents in the default collections have finished.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="usage"><a class="anchor" href="#usage"></a>Usage</h3>
<div class="paragraph">
<p>Custom metadata collections are enabled with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L733-L741">cluster, err := gocb.Connect("localhost", gocb.ClusterOptions{
	TransactionsConfig: gocb.TransactionsConfig{
		MetadataCollection: &amp;gocb.TransactionKeyspace{
			BucketName:     "travel-sample",
			ScopeName:      "transactions",
			CollectionName: "metadata",
		},
	},
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>When specified:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any transactions created from this <code>Transactions</code> object, will create and use metadata in that collection.</p>
</li>
<li>
<p>The asynchronous cleanup started by this <code>Transactions</code> object will be looking for expired transactions only in this collection, unless additional <code>CleanupCollections</code> are provided or a transaction explicitly overrides the metadata collection.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You need to ensure that this application has RBAC data read and write privileges to it, and should not delete the collection subsequently as it can interfere with existing transactions.
You can use an existing collection or create a new one.</p>
</div>
<div class="paragraph">
<p>Custom metadata collections can also be provided at the transaction level itself:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go" data-source-url="file:///Users/mariashodunke/Couchbase/docs/docs-sdk-go//modules/devguide/examples/go/transactions.go#L750-L756">metaCollection := cluster.Bucket("travel-sample").Scope("transactions").Collection("other-metadata")
result, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {
	// ... transactional code here ...
	return nil
}, &amp;gocb.TransactionOptions{
	MetadataCollection: metaCollection,
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will override any metadata collection that has been provided at the <code>Transactions</code> level.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="further-reading"><a class="anchor" href="#further-reading"></a>Further Reading</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thereâ€™s plenty of explanation about how transactions work in Couchbase in our <a href="../../../server/7.0/learn/data/transactions.html" class="xref page">Transactions documentation</a>.</p>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span>Â© 2022 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
